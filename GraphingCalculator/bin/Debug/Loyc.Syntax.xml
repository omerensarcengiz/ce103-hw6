<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Syntax</name>
    </assembly>
    <members>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Write(System.Char)">
            <summary>Appends a character to the output stream or StringBuilder.</summary>
            <remarks>Do not call <c>Write('\n')</c>; call <see cref="!:Newline()"/> instead.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Write(System.String)">
            <summary>Appends a string to the output stream or StringBuilder.</summary>
            <remarks>The string should not include newlines (if it might, call 
            <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteSmartly(Loyc.Syntax.Impl.ILNodePrinterHelper,Loyc.UString)"/> instead).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Write(Loyc.UString)">
            <summary>Appends a string to the output stream or StringBuilder.</summary>
            <remarks>The string should not include newlines (if it might, call 
            <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteSmartly(Loyc.Syntax.Impl.ILNodePrinterHelper,Loyc.UString)"/> instead).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Space">
            <summary>Writes a space character unless the last character written was a space.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Newline(System.Boolean)">
            <summary>Appends a newline, with indentation afterward according to the 
            current indentation level.</summary>
            <param name="deferIndent">Requests that the indentation after the newline not
            be printed until <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Write(System.Char)"/> or <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.FlushIndent"/> is called.
            This option is provided because you may know that you want to print a newline
            before deciding what indent is needed.</param>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.FlushIndent">
            <summary>Writes the pending indent, if applicable. This allows you to call 
            <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Indent(Loyc.Syntax.Impl.PrinterIndentHint)"/> or <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Dedent(Loyc.Syntax.Impl.PrinterIndentHint)"/> afterward while making sure the 
            indentation on the current line is unaffected.</summary>
            <remarks>This method has no effect if indentation has already been written, 
            e.g. right after calling Newline(false) or Write(char). If a newline is pending
            as a result of a call to <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.NewlineIsRequiredHere"/>, it is implementation-
            defined whether that additional newline (and its indent) is written. 
            <see cref="T:Loyc.Syntax.Impl.LNodePrinterHelper"/> write a newline when this method is called,
            but it sets a special internal flag so that a call sequence such as
              <code>NewlineIsRequiredHere().FlushIndent().NewlineIsRequiredHere().Newline()</code>
            writes only a single newline.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.NewlineIsRequiredHere">
            <summary>Requests that a newline be written at this location. If this method is 
            called multiple times at the same location, or if <see cref="!:Newline(int)"/> is 
            called immediately afterward, only a single newline is written.</summary>
            <remarks>
            This method does not officially write a newline; if you call this method followed 
            by <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Dedent(Loyc.Syntax.Impl.PrinterIndentHint)"/>, for example, the newline that is eventually written will 
            be followed by a lower amount of indentation.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Indent(Loyc.Syntax.Impl.PrinterIndentHint)">
            <summary>Informs the helper that the printer is starting to write the specified 
            node. The printer must call <see cref="!:EndNode"/> when it is done. This 
            information may be used to record range information (to understand why this is
            useful, please read about <see cref="T:Loyc.Syntax.LNodeRangeMapper"/>)</summary>
            <param name="node">The node that begins here.</param>
            <summary>Increases the current indent level.</summary>
            <param name="hint">Information associated with the indent, typically a member 
            of <see cref="T:Loyc.Syntax.Impl.PrinterIndentHint"/> that influences how indentation is performed.
            You can use null for standard indentation.</param>
            <remarks>
            This interface does not define what string is used for an indent; 
            typically it's a tab or 2 to 4 spaces.
            <para/>
            The standard kind of indentation expresses block boundaries, e.g. statements are 
            indented between curly braces (in languages in the C family).
            <para/>
            When printing labels (targets of goto statements), a typical style is that labels 
            are printed with less indentation than a normal statement. The 
            <see cref="F:Loyc.Syntax.Impl.PrinterIndentHint.Label"/> hint indicates that a label is about to
            be printed.
            <para/>
            Another interesting case is a mid-expression break. Consider a statement 
            <c>x = 2 * (1 + Method(@`%newline` parameter1, parameter2))</c>
            with a newline before parameter1. It is the printer's responsibility to notice the 
            trivia and call <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Newline(System.Boolean)"/>, but in this case the newline should 
            include some extra indentation to indicate that a new statement does not begin
            here. The <see cref="F:Loyc.Syntax.Impl.PrinterIndentHint.Subexpression"/> and <see 
            cref="F:Loyc.Syntax.Impl.PrinterIndentHint.Brackets"/> hints request this extra indentation; both of 
            these flags indicate a subexpression but the latter is meant to imply a kind of 
            subexpression that begins with round or square brackets `() []`.
            <para/>
            <see cref="T:Loyc.Syntax.Impl.LNodePrinterHelper"/> has an indent stack which it uses to make a
            smart decision about indentation. When printing the example above, if your code
            calls <see cref="!:Indent(Symbol)"/> with an appropriate hint as it begins each node, 
            the helper will know that four subexpressions have begun but not ended at the time 
            <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Newline(System.Boolean)"/> is called:
            <ul>
            <li><c>2 * (1 + Method(@`%newline` parameter1, parameter2))</c></li>
            <li><c>(1 + Method(@`%newline` parameter1, parameter2))</c></li>
            <li><c>Method(@`%newline` parameter1, parameter2))</c></li>
            <li><c>@`%newline` parameter1</c></li>
            </ul>
            <see cref="T:Loyc.Syntax.Impl.LNodePrinterHelper"/> counts the number of "indents" of type
            <see cref="F:Loyc.Syntax.Impl.PrinterIndentHint.Brackets"/> and then prints indentation based on
            properties that were given to its constructor 
            (<see cref="P:Loyc.Syntax.Impl.LNodePrinterHelper.BracketIndentString"/> and
            <see cref="P:Loyc.Syntax.Impl.LNodePrinterHelper.MaxBracketIndents"/>). It treats the 
            <see cref="F:Loyc.Syntax.Impl.PrinterIndentHint.Subexpression"/> hint differently; it ignores the
            number of Subexpressions on the indent stack and only pays attention to whether 
            there are zero of them, or more than zero. Any number of Subexpression indents 
            larger than zero causes a single bracket indent to be printed. However, if 
            there are also bracket indents on the stack, then the Subexpression indents 
            have no effect.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.IPrinterHelper`1.Dedent(Loyc.Syntax.Impl.PrinterIndentHint)">
            <summary>Decreases the current indent level.</summary>
            <param name="mode">If the hint is not null, the writer may be able to check 
            that it was the same hint that was passed to <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Indent(Loyc.Syntax.Impl.PrinterIndentHint)"/> and
            throw an exception if not.</param>
            <exception cref="T:System.ArgumentException">Hint provided doesn't match Indent hint</exception>
        </member>
        <member name="P:Loyc.Syntax.Impl.IPrinterHelper`1.IsAtStartOfLine">
            <summary>Returns true iff nothing has been written since the last call to 
            <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.Newline(System.Boolean)"/> or <see cref="M:Loyc.Syntax.Impl.IPrinterHelper`1.NewlineIsRequiredHere"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Impl.IPrinterHelper`1.LastCharWritten">
            <summary>Gets the character most recently written to the stream, or 
            '\uFFFF' if no characters have been written.</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.ILNodePrinterHelper`1">
            <summary>A fluent interface for classes that help you print syntax trees (<see cref="T:Loyc.Syntax.ILNode"/>s).</summary>
            <typeparam name="Self">The return type of methods in this interface.</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelper`1.EndNode">
            <summary>Informs the helper that the printer is done writing the most recently
            started node. The helper may save the range of the node, e.g. by calling 
            <see cref="P:Loyc.Syntax.ILNodePrinterOptions.SaveRange"/>.</summary>
            <param name="abort">Indicates that the range of this node should not be saved.</param>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelper`1.BeginNode(Loyc.Syntax.ILNode,Loyc.Syntax.Impl.PrinterIndentHint)">
            <summary>Combines the <see cref="M:Loyc.Syntax.Impl.ILNodePrinterHelper`1.BeginNode(Loyc.Syntax.ILNode)"/> and <see cref="!:Indent"/> operations.</summary>
            <param name="indentHint">Typically a member of <see cref="T:Loyc.Syntax.Impl.PrinterIndentHint"/> 
            that influences how indentation is performed</param>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelper`1.EndNode(Loyc.Syntax.Impl.PrinterIndentHint)">
            <summary>Combines the <see cref="M:Loyc.Syntax.Impl.ILNodePrinterHelper`1.EndNode"/> and <see cref="!:Dedent"/> operations.</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.ILNodePrinterHelper">
            <summary>A version of <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelper`1"/> without a type parameter.</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.PrinterIndentHint">
            <summary>Values used with <see cref="!:ILNodePrinterHelper&lt;Self&gt;.Newline(Symbol)"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.PrinterIndentHint.Normal">
            <summary>Requests normal (statement) indentation (this is the default)</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.PrinterIndentHint.Subexpression">
            <summary>Specifies that a subexpression has started.</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.PrinterIndentHint.NoIndent">
            <summary>Requests no indentation. This is sometimes useful to help 
            achieve a simple printer structure that uses either Indent(Subexpression) 
            or Indent(NoIndent) at the beginning with an unconditional Dedent() at
            the end, so that you don't need to keep track of whether or not you 
            called Indent.</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.PrinterIndentHint.Brackets">
            <summary>Specifies that brackets (parentheses or square brackets) have started.</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.PrinterIndentHint.Label">
            <summary>Requests label-tyle indentation</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.LNodePrinterHelperExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelper"/></summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteSmartly(Loyc.Syntax.Impl.ILNodePrinterHelper,Loyc.UString)">
            <summary>Appends a string, except newline ('\n') characters which are translated
            into calls to <see cref="!:Newline()"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.SpaceIf(Loyc.Syntax.Impl.ILNodePrinterHelper,System.Boolean)">
            <summary>Appends a space to the output stream or StringBuilder if the 
            parameter is true.</summary>
            <remarks>This helper method exists because printers often want to add spaces 
            conditionally, e.g. it might want to add spaces around the current binary 
            operator if it is not `.` or `?.`.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.NewlineOrSpace``1(Loyc.Syntax.Impl.ILNodePrinterHelper,System.Boolean)">
            <summary>NewlineOrSpace(true) appends a newline while NewlineOrSpace(false) 
            appends a space.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.IrrevokableNewline(Loyc.Syntax.Impl.ILNodePrinterHelper)">
            <summary>Creates an newline that cannot be revoked later by calling 
            NewlineIsRequiredHere() followed by Newline().</summary>
            <remarks>This should be an extension method for <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2"/>
            but C# 9 fails to infer type argument C in that case.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteOpening(Loyc.Syntax.Impl.ILNodePrinterHelper,System.Char)">
            <summary>Calls <c>self.Write(c).Indent(PrinterIndentHint.Brackets)</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteOpening(Loyc.Syntax.Impl.ILNodePrinterHelper,System.String)">
            <summary>Calls <c>self.Write(s).Indent(PrinterIndentHint.Brackets)</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteClosing(Loyc.Syntax.Impl.ILNodePrinterHelper,System.Char)">
            <summary>Calls <c>self.Write(c).Dedent(PrinterIndentHint.Brackets)</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.WriteClosing(Loyc.Syntax.Impl.ILNodePrinterHelper,System.String)">
            <summary>Calls <c>self.Write(s).Dedent(PrinterIndentHint.Brackets)</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2">
            <summary>Enhances <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelper`1"/> with an 
            ability to revoke newlines.</summary>
            <typeparam name="Self">The return type of methods in the base interface.</typeparam>
            <typeparam name="Checkpoint">A type returned by <see cref="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.GetCheckpoint"/>
            representing a location in the output stream.</typeparam>
            <remarks>
            When pretty-printing any language as text, it's a challenge to decide
            where to place newlines. You may want to break up long lines into
            shorter ones, as in
            <pre>
            if (ReallyLongIdentifier[Fully.Qualified.Name(multiple, parameters)] 
               > SomeConstant)
            {
               return ReallyLongIdentifier[firstThing + secondThing] 
                  + thirdThing + fourthThing;
            }
            </pre>
            Conversely, you may want to print something on one line that you would
            ordinarily print on two:
            <pre>
                if (c) break;
            </pre>
            Of course, the problem is, you don't know how long the syntax tree 
            will be in text form until after you try to print it.
            <para/>
            My first idea to solve this problem was to use a 
            <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">rope</a> 
            tree data structure - inner syntax trees would produce small strings 
            that could be "roped" together to produce a bigger tree. But ropes tend
            not to use memory efficiently, and there was the challenge, which I 
            didn't see how to solve, of how to keep the tree balanced efficiently 
            (for this particular application perhaps a balanced tree wasn't needed,
            but as a perfectionist I didn't want to implement a "half-baked" data 
            structure.)
            <para/>
            Next I thought of a simpler solution based on an ordinary StringBuilder. 
            My idea was to insert newlines "pessimistically" - insert them 
            everywhere in which they might be needed - and then selectively "revoke" 
            them later if they turn out to be unnecessary. Only the most 
            recently-written newline(s) can be revoked, which keeps the implementation 
            simple and also limits the performance cost of deleting the newlines.
            <para/>
            To use, call Newline() to write a newline (with indentation). To make 
            a decision about whether to keep or revoke the most recent newline(s), 
            call RevokeOrCommitNewlines(cp, maxLineLength) where cp is a "checkpoint"
            representing some point before the first newline you want to potentially
            revoke, and maxLineLength is the line length threshold: if the line length 
            after combining lines, starting at the line on which the checkpoint is 
            located, does not exceed maxLineLength, then the newlines are revoked, 
            otherwise ALL newlines are committed (so earlier newlines can no longer 
            be revoked.)
            <para/>
            This design allows a potentially long series of newlines to be deleted
            in the reverse order that they were created, but if any newline is kept
            then previous ones can no longer be deleted.
            <para/>
            For an example of how this is used, see the JSON printer in LLLPG samples
            or look at the implementation of the LESv3 printer.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.NewlineAfterCheckpoint">
            <summary>Appends a newline, returning a checkpoint from with indentation afterward according to the 
            current indentation level.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.GetCheckpoint">
            <summary>Gets a value that can be passed later to <see cref="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.RevokeNewlinesSince(`0)"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.LineWidth">
            <summary>Gets the current width of the current line (typically measured in characters).</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.RevokeNewlinesSince(`0)">
            <summary>Deletes uncommitted newlines that were written after the specified checkpoint.</summary>
            <returns>The number of newlines that were just revoked.</returns>
            <remarks>Newlines created after a call to 
            <see cref="!:ILNodePrinterHelper&lt;Self&gt;.NewlineIsRequiredHere"/> or 
            <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelperExt.IrrevokableNewline(Loyc.Syntax.Impl.ILNodePrinterHelper)"/> are not revoked.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.CommitNewlines">
            <summary>Commits all uncommitted newlines permanently.</summary>
            <remarks>Also causes ranges after the uncommitted newlines to be saved.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2.RevokeOrCommitNewlines(`0,System.Int32)">
            <summary>Revokes or commits newlines added since the specified 
            checkpoint. Recent newlines are revoked if the combined line length 
            after revokation does not exceed <c>maxLineWidth</c>, otherwise ALL
            newlines are committed permanently.</summary>
            <returns>0 if the method had no effect, -N if N newlines were 
            revoked, and +N if N newlines were committed.</returns>
            <remarks>This method does not affect the indent level.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`1">
            <summary>Alias for <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2"/> 
            without the second type parameter.</summary>
        </member>
        <member name="T:Loyc.Syntax.Impl.LNodePrinterHelper">
            <summary>A helper type for printer objects; for details, please see
            <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelper`1"/>, its derived interface
            <see cref="T:Loyc.Syntax.Impl.ILNodePrinterHelperWithRevokableNewlines`2"/>, and the documentation of the
            constructor <see cref="!:LNodePrinterHelper(StringBuilder, string, string, bool, string, string)"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Impl.LNodePrinterHelper.SaveRange">
            <summary>Gets or sets a method that is called when the node's range in the 
            output is locked in (after you call <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.EndNode"/>).</summary>
            <remarks>The third parameter of the method is the node's depth in the
            syntax tree (e.g. 3 means that the node has three known parents).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Reset">
            <summary>Calls Dispose() and resets the state of this object, like calling the constructor.
            Does not clear the <see cref="P:Loyc.Syntax.Impl.LNodePrinterHelper.StringBuilder"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.LNodePrinterHelper.PendingAction.Newline">
            <summary>A "collapsable" newline requested by NewlineIsRequiredHere</summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.LNodePrinterHelper.PendingAction.Indent">
            <summary>A delayed indent requested by Newline(deferIndent: true)</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Loyc.Syntax.Impl.LNodePrinterHelper.PendingAction.NodeStarted" -->
        <member name="F:Loyc.Syntax.Impl.LNodePrinterHelper.PendingAction.NodeEnded">
            <summary>Flag set by <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.EndNode"/></summary>
        </member>
        <member name="F:Loyc.Syntax.Impl.LNodePrinterHelper.PendingAction.CollapsableNewlineWasJustWritten">
            <summary>A special flag that is needed to stop FlushIndent from interfering with newlines</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Write(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Write(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Write(Loyc.UString)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Space">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.OnNodeChanged(System.Char)">
            <summary>This method, which does nothing by default, is called by all three 
            versions of Write() when the first character is written after a call to
            <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.BeginNode(Loyc.Syntax.ILNode)"/> or <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.EndNode"/>. You can override 
            this method can detect conflicts between this character and the previous 
            characters in the stream (<see cref="P:Loyc.Syntax.Impl.LNodePrinterHelper.LastCharWritten"/>).</summary>
            <param name="firstChar">First character in the new node, which has not
            been written yet</param>
            <remarks>
            For example, suppose a language has a prefix operator `.` and two binary
            operators called `?.` and `?`. If the last character printed was `?` then
            it should not be followed by `.` if the `.` is part of a different node,
            since the parser would treat `?.` as a single token rather than the 
            intended two tokens. A derived class can use this method to detect the
            conflict and prevent it by adding a space to <see cref="P:Loyc.Syntax.Impl.LNodePrinterHelper.StringBuilder"/>.
            (If you call <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.Write(System.Char)"/> to do this, it will cause this 
            method to be called again.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Impl.LNodePrinterHelper.Length">
            <summary>Current length of the output string. This length can decrease if 
            newlines are revoked.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Newline(System.Int32)">
            <summary>Older version of Newline method, which returns a checkpoint instead of <c>this</c>.</summary>
            <param name="changeIndentLevel">Amount by which to change the indent level (positive, negative or zero).</param>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Newline(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.AppendIndentAfterNewline(System.Int32)">
            <summary>Called just after a newline is emitted to append indentation.</summary>
            <param name="hint">The hint that was passed to <see cref="M:Loyc.Syntax.Impl.LNodePrinterHelper.Newline(System.Int32)"/></param>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.NewlineIsRequiredHere">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Indent(Loyc.Syntax.Impl.PrinterIndentHint)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Dedent(Loyc.Syntax.Impl.PrinterIndentHint)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.BeginNode(Loyc.Syntax.ILNode)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.EndNode">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.BeginNode(Loyc.Syntax.ILNode,Loyc.Syntax.Impl.PrinterIndentHint)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.EndNode(Loyc.Syntax.Impl.PrinterIndentHint)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.GetCheckpoint">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.NewlineAfterCheckpoint">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.RevokeOrCommitNewlines(Loyc.Syntax.Impl.LNodePrinterHelperLocation,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.CommitNewlines">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.RevokeNewlinesSince(Loyc.Syntax.Impl.LNodePrinterHelperLocation)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Dispose">
            <summary>Commits uncommitted newlines and node ranges. Throws if 
            a SaveRange method was provided but EndNode has not been called 
            the correct number of times.</summary>
        </member>
        <member name="M:Loyc.Syntax.Impl.LNodePrinterHelper.Revoke(Loyc.Syntax.Impl.LNodePrinterHelper.Revokable)">
            <summary>Revokes (deletes) the last newline created, and its indent.</summary>
            <param name="r">Object returned from Newline()</param>
            <remarks>Only the most recent newline can be revoked, and of course, 
            it can only be revoked once. Multiple newlines can be revoked if 
            they are revoked in the reverse order in which they were created.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Impl.LNodePrinterHelperLocation">
            <summary>A location in the output stream of <see cref="T:Loyc.Syntax.Impl.LNodePrinterHelper"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IParsingOptions">
            <summary>A set of relatively universal parsing options that 
            <see cref="T:Loyc.Syntax.IParsingService"/>s should understand.</summary>
            <seealso cref="T:Loyc.Syntax.ParsingOptions"/>
        </member>
        <member name="P:Loyc.Syntax.IParsingOptions.Mode">
            <summary>A <see cref="T:Loyc.Syntax.ParsingMode"/> value indicating which part of the 
            language is being parsed (e.g. expressions, or an entire file).</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingOptions.PreserveComments">
            <summary>Whether to preserve comments and newlines by attaching trivia 
            attributes to the output. If <see cref="P:Loyc.Syntax.IParsingService.CanPreserveComments"/> 
            is false, this parameter will have no effect.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingOptions.SurfaceScanOnly">
            <summary>Indicates that the parsing service is only being used for 
            syntax highlighting, so the content of literals is not important. The
            produced tokens or LNode can claim every literal is null.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingOptions.SpacesPerTab">
            <summary>If tabs are significant, this option controls the number of 
            spaces a single tab should be equated with.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingOptions">
            <summary>A simple implementation of <see cref="T:Loyc.Syntax.IParsingOptions"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2Lexer">
            <summary>Lexer for EC# source code.</summary>
            <seealso cref="T:Loyc.Syntax.Lexing.ILexer`1"/>
            <seealso cref="T:Loyc.Syntax.Lexing.TokensToTree"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Lexer.SkipValueParsing">
            <summary>Used for syntax highlighting, which doesn't care about token values.
            This option causes the Token.Value to be set to a default, like '\0' for 
            single-quoted strings and 0 for numbers. Operator names are still parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes. Supports quote types '\'', '"' and '`'.</summary>
            <param name="sourceText">input text</param>
            <param name="onError">Called in case of parsing error (unknown escape sequence or missing end quotes)</param>
            <param name="indentation">Inside a triple-quoted string, any text
            following a newline is ignored as long as it matches this string. 
            For example, if the text following a newline is "\t\t Foo" and this
            string is "\t\t\t", the tabs are ignored and " Foo" is kept.</param>
            <param name="les3TQIndents">Enable EC# triple-quoted string indent
            rules, which allow an additional one tab or three spaces of indent.
            (I'm leaning toward also supporting this in LES; switched on in v3)</param>
            <returns>The decoded string</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.
            Firstly, it recognizes triple-quoted strings (''' """ ```). These 
            strings enjoy special newline handling: the newline is always 
            interpreted as \n regardless of the actual kind of newline (\r and 
            \r\n newlines come out as \n), and indentation following the newline
            can be stripped out. Triple-quoted strings can have escape sequences
            that use both kinds of slash, like so: <c>\n/ \r/ \'/ \"/ \0/</c>.
            However, there are no unicode escapes (\u1234/ is NOT supported).
            <para/>
            Secondly, it recognizes normal strings (' " `). These strings stop 
            parsing (with an error) at a newline, and can contain C-style escape 
            sequences: <c>\n \r \' \" \0</c> etc. C#-style verbatim strings are 
            NOT supported.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes (see documentation of the first overload) into a 
            StringBuilder.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.UnescapeString(Loyc.UString@,System.Char,System.Boolean,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string whose starting quotes 
            have been stripped out. If triple-quote parsing was requested, stops 
            parsing at three quote marks; otherwise, stops parsing at a single 
            end-quote or newline.</summary>
            <returns>true if parsing stopped at one or three quote marks, or false
            if parsing stopped at the end of the input string or at a newline (in
            a string that is not triple-quoted).</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Lexer.ParseIdentifier(Loyc.UString@,System.Action{System.Int32,System.String},System.Boolean@)">
            <summary>Parses an LES2-style identifier such as <c>foo</c>, <c>@foo</c>, 
            <c>@`foo`</c> or <c>@--punctuation--</c>.
            </summary>
            <param name="source">Text to parse. On return, the range has been 
            decreased by the length of the token; this method also stops if this
            range becomes empty.</param>
            <param name="onError">A method to call on error</param>
            <param name="checkForNamedLiteral">This is set to true when the input 
            starts with @ but doesn't use backquotes, which could indicate that 
            it is an LES named literal such as @false or @null.</param>
            <returns>The parsed version of the identifier.</returns>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2Parser">
            <summary>Parses LES (Loyc Expression Syntax) code into a sequence of Loyc 
            trees (<see cref="T:Loyc.Syntax.LNode"/>), one per top-level statement.</summary>
            <remarks>
            You can use <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/> with <see cref="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)"/>
            to easily parse a text string (holding zero or more LES statements) into a Loyc tree.
            <para/>
            This class expects to receive tokens from <see cref="T:Loyc.Syntax.Les.Les2Lexer"/> that have been 
            preprocessed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, with whitespace tokens filtered out.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Parser.Start(Loyc.Holder{Loyc.Syntax.Les.TokenType})">
            <summary>Top-level rule: expects a sequence of statements followed by EOF</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3Lexer.PreferCustomLiterals">
            <summary>If this flag is true, all literals except plain strings and
            true/false/null are stored as CustomLiteral, bypassing number parsing 
            so that all original characters are preserved if the output is written 
            back to text.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes. Supports quote types '\'', '"' and '`'.</summary>
            <param name="sourceText">input text</param>
            <param name="onError">Called in case of parsing error (unknown escape sequence or missing end quotes)</param>
            <param name="indentation">Inside a triple-quoted string, any text
            following a newline is ignored as long as it matches this string. 
            For example, if the text following a newline is "\t\t Foo" and this
            string is "\t\t\t", the tabs are ignored and " Foo" is kept.</param>
            <param name="allowExtraIndent">Enable EC#/LES triple-quoted string 
            indent rules, which allow an additional one tab or three spaces of 
            indent beyond what the identation parameter specifies.</param>
            <returns>The decoded string</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.
            Firstly, it recognizes triple-quoted strings (''' """ ```). These 
            strings enjoy special newline handling: the newline is always 
            interpreted as \n regardless of the actual kind of newline (\r and 
            \r\n newlines come out as \n), and indentation following the newline
            can be stripped out. Triple-quoted strings can have escape sequences
            that use both kinds of slash, like so: <c>\n/ \r/ \'/ \"/ \0/</c>.
            However, there are no unicode escapes (\u1234/ is NOT supported).
            <para/>
            Secondly, it recognizes normal strings (' " `). These strings stop 
            parsing (with an error) at a newline, and can contain C-style escape 
            sequences: <c>\n \r \' \" \0</c> etc. C#-style verbatim strings are 
            NOT supported.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Lexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes (see documentation of the first overload) into a 
            StringBuilder.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Lexer.UnescapeString(Loyc.UString@,System.Char,System.Boolean,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString,System.Boolean)">
            <summary>Parses a normal or triple-quoted string whose starting quotes 
            have been stripped out. If triple-quote parsing was requested, stops 
            parsing at three quote marks; otherwise, stops parsing at a single 
            end-quote or newline.</summary>
            <returns>true if parsing stopped at one or three quote marks, or false
            if parsing stopped at the end of the input string or at a newline (in
            a string that is not triple-quoted).</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Lexer.GetOperatorTokenType(Loyc.UString)">
            <summary>Under the assumption that <c>op</c> is a sequence of punctuation 
            marks that forms a legal operator, this method decides its TokenType.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Parser.Start(Loyc.Holder{Loyc.Syntax.Les.TokenType})">
            <summary>Top-level rule: expects a sequence of statements followed by EOF</summary>
            <param name="separator">If there are multiple expressions, the Value of 
            this Holder is set to the separator between them: Comma or Semicolon.</param>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3PrettyPrinter">
            <summary>
            A variant of <see cref="T:Loyc.Syntax.Les.Les3Printer"/> that adds syntax highlighting 
            in one of three ways: as console output, as HTML output, or as 
            <see cref="T:Loyc.Syntax.Les.LesColorCode"/> control codes. 
            </summary>
            <remarks>
            Create an instance by invoking the constructor, then call 
            <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToConsole(Loyc.Syntax.ILNode,System.Boolean)"/> for console output, <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/> 
            for HTML output, or <see cref="M:Loyc.Syntax.Les.Les3Printer.Print(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode})"/> 
            for just control codes.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrettyPrinter.ColorCodesToCssClasses">
            <summary>The lookup table of strings for control codes (<see cref="T:Loyc.Syntax.Les.LesColorCode"/> 
            values) to HTML classes, used by <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean)"/>.</summary>
            <remarks>This property is null by default, which causes the default 
            table to be used. See <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable"/> for more 
            information.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.#ctor(Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Creates an instance of this class, which produces plain LES 
            augmented with control codes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.#ctor(System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Creates an instance of this class, which produces plain LES 
            augmented with control codes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable">
            <summary>The lookup table of strings for control codes (<see cref="T:Loyc.Syntax.Les.LesColorCode"/> values) to HTML classes.</summary>
            <remarks>
            For example, <c>GetDefaultCssClassTable()[(int)LesColorCode.Number]</c> indicates 
            the default CSS class to use for numbers.
            <para/>
            If the entry for a given code is null, no span element is emitted, which 
            shortens the output.
            <para/>
            The default class names are shared with the Pygments syntax highlighting
            system. A list of the CSS classes available in Pygments is available 
            <a href="https://github.com/zeke/pygments-tokens">at this link</a>.
            Only a small subset of these classes are used in this table.
            <para/>
            Here is some suitable CSS:
            <pre>
            .highlight { background-color: #f8f8f8; color: #111; }
            .highlight .c  { color: #5A5; } /* Comment */
            .highlight .n  { color: #111; } /* Name (omitted by default) */
            .highlight .m  { color: #909; } /* Number */
            .highlight .s  { color: #B44; } /* String */
            .highlight .l  { color: #B04; } /* Literal (other) */
            .highlight .kc { color: #41F; } /* Keyword.Constant */
            .highlight .o  { color: #940; } /* Operator */
            .highlight .p  { color: #111; } /* Punctuation (omitted by default) */
            .highlight .kp { color: #33A; } /* Keyword.Pseudo (@attribute) */
            .highlight .nb { color: #007; } /* Name.Builtin (#specialId) */
            .highlight .k  { color: #11F; } /* Keyword (.dotId) */
            .highlight .x  { color: #D00; } /* Other */
            .highlight .pi { color: #B50; } /* Parenthesis Inner (()) */
            </pre>
            <para/>
            Note: LesTokenCode.Opener and LesTokenCode.Closer are handled 
            specially. An opener and its matching closer (e.g. '(' and ')') are always 
            given the same color, but nested parens/brackets are given alternating 
            colors (CSS classes), with the entry for LesTokenCode.Opener used for outer
            parens and the entry for LesTokenCode.Closer used for inner parens. The
            default class name is "pi" for inner parentheses; no class name is used
            for outer parens. "pi" is not a standard name, so if you're using a 
            standard Pygment stylesheet you should add an extra line, e.g.
            <pre>
            .highlight .p { color: #111; } /* Punctuation (includes , ; { }) */
            .highlight .pi { color: #B50; } /* Parenthesis Inner */
            </pre>
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Prints an LNode as LESv3 with HTML syntax highlighting elements.</summary>
            <param name="nodes">Syntax trees to print.</param>
            <param name="output">Output StringBuilder for HTML code.</param>
            <param name="addPreCode">Whether to wrap the output in "&lt;pre class='highlight'>&lt;code>" tags.</param>
            <param name="options">Options to control the style for code printing.</param>
            <returns>The output StringBuilder</returns>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(Loyc.Syntax.ILNode,System.Text.StringBuilder,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtml(System.Collections.Generic.IEnumerable{Loyc.Syntax.ILNode},System.Text.StringBuilder,System.Boolean,Loyc.IMessageSink,Loyc.Syntax.ILNodePrinterOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrettyPrinter.PrintToHtmlCore(System.Text.StringBuilder,System.Text.StringBuilder,System.Boolean,System.String,System.String[])">
            <summary>Converts a StringBuilder with <see cref="T:Loyc.Syntax.Les.LesColorCode"/> 
            control codes to HTML with Pygments CSS class codes.</summary>
            <param name="input">Input containing <see cref="T:Loyc.Syntax.Les.LesColorCode"/> control characters.</param>
            <param name="output">Output StringBuilder for HTML code. If null, a new one is created.</param>
            <param name="addPreCode">Whether to wrap the output in "&lt;pre class='highlight'>&lt;code>" tags.</param>
            <param name="newline">What to write to <c>output</c> when '\n' is encountered.</param>
            <param name="colorCodesToCssClasses">CSS class table for span tags, 
            see <see cref="M:Loyc.Syntax.Les.Les3PrettyPrinter.GetDefaultCssClassTable"/>.</param>
            <returns>The output StringBuilder.</returns>
        </member>
        <member name="T:Loyc.Syntax.Les.LesColorCode">
            <summary>These codes are produced as control characters (i.e. cast to char)
            in the output of <see cref="T:Loyc.Syntax.Les.Les3PrettyPrinter"/>.</summary>
            <remarks>
            A note about implementation coupling: <see cref="T:Loyc.Syntax.Les.Les3PrettyPrinter"/> relies 
            on color codes provided to it by the base class <see cref="T:Loyc.Syntax.Les.Les3Printer"/>.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3Printer.MessageSink">
            <summary>Target for warning messages.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3Printer.Chars">
            <summary>
            Based on these flags, StartToken() and WriteToken() ensure that two 
            adjacent tokens aren't treated like a single token when reparsed, by 
            printing a space between them if necessary.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3Printer.NewlineContext">
            <summary>Used to help keep track of where newline trivia (and single-
            line comments ending in a newline) are permitted, to avoid printing
            newline trivia where it would count as "end of expression".</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Printer.CanBeBinaryOperator(System.String)">
            <summary>Returns true if the given name can be printed as a binary operator in LESv3.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3Printer.CanBePrefixOperator(System.String)">
            <summary>Returns true if the given name can be printed as a prefix operator in LESv3.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.CustomLiteral">
            <summary>A custom literal is a normal number or string paired with a 
            (typically unrecognized) type prefix or suffix.</summary>
            <remarks>This structure is used as the value of an LESv3 token to 
            represent non-standard numbers and strings such as <c>1.1unum</c> 
            and <c>bytes"ab cd"</c></remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.CustomLiteral.Value">
            <summary>The numeric or string value of the literal.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.CustomLiteral.TypeMarker">
            <summary>A prefix or suffix on the literal that represents some 
            additional meaning.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3PrinterOptions">
            <summary>A set of extended options supported when printing in LES3.</summary>
            <remarks>This type can be used, for example, in a call to 
            <see cref="M:Loyc.Syntax.Les.Les3LanguageService.Print(Loyc.Syntax.ILNode,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)"/>.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideListBrackets">
            <summary>Whether to print a space inside square brackets for lists <c>[ ... ]</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideArgLists">
            <summary>Whether to print a space inside argument lists like <c>f( ... )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideGroupingParens">
            <summary>Whether to print a space inside grouping parentheses <c>( ... )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceInsideTuples">
            <summary>Whether to print a space inside tuples like <c>f( ...; )</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAfterComma">
            <summary>Whether to print a space after each comma in an argument list.</summary>
            <remarks>Initial value: true</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.AllowExtraParenthesis">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list [] to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * @+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a slightly different tree (the parenthesis
            add the trivia attribute %inParens.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaNewline"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.WarnAboutUnprintableLiterals">
            <summary>Whether to print a warning when an "unprintable" literal is 
            encountered. In any case the literal is converted to a string, placed 
            in double quotes and prefixed by the unqualified Type of the Value.</summary>
            <remarks>Initial value: true</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpacesBetweenAppendedStatements">
            <summary>Whether to add a space between multiple statements printed on
            one line (initial value: true).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.UseRedundantSemicolons">
            <summary>If true, a semicolon is used in addition to the usual newline to 
            terminate each expression inside braced blocks and at the top level.</summary>
            <remarks>Regardless of this flag, a semicolon is forced to appear when a 
            node uses <see cref="F:Loyc.Syntax.CodeSymbols.TriviaAppendStatement"/> to put multiple 
            expressions on one line.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.PrefixNotationOnly">
            <summary>
            Print purely in prefix notation, e.g. <c>`'+`(2,3)</c> instead of <c>2 + 3</c>.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAroundInfixStopPrecedence">
            <summary>The printer avoids printing spaces around infix (binary) 
            operators that have the specified precedence or higher.</summary>
            <seealso cref="T:Loyc.Syntax.Les.LesPrecedence"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les3PrinterOptions.SpaceAfterPrefixStopPrecedence">
            <summary>The printer avoids printing spaces after prefix operators 
            that have the specified precedence or higher.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.ForcedLineBreakThreshold">
            <summary>Although the LES3 printer is not designed to insert line breaks
            mid-expression or to keep lines under a certain length, this option can 
            avoid extremely long lines in some cases, by (1) inserting line breaks 
            after commas in argument lists, or after very long attribute lists, and 
            (2) ignoring the <see cref="F:Loyc.Syntax.CodeSymbols.TriviaAppendStatement"/> 
            attribute when an expression within a braced block starts after this 
            column on a line.
            </summary>
            <remarks>
            The default value is 120.
            <para/>
            Setting the threshold to zero forces all "statements" (expressions 
            in braces) to appear on a new line. Lines can still be arbitrarily long 
            with this option, since breaks are only added at the end of expressions 
            within a braced block.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les3PrinterOptions.DigitSeparator">
            <summary>Sets the "thousands" or other digit separator for numeric 
            literals. Valid values are null (to disable the separator), underscore (_) 
            and single quote (').</summary>
            <exception cref="T:System.ArgumentException">Invalid property value.</exception>
            <remarks>
            For decimal numbers, this value separates thousands (e.g. 12'345'678).
            For hex numbers, it separates groups of four digits (e.g. 0x1234'5678).
            For binary numbers, it separates groups of eight digits.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2LanguageService">
            <summary>The <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/> property provides easy access to the lexer, 
            parser and printer for Loyc Expression Syntax (LES).</summary>
            <remarks>
            LES overview: http://loyc.net/les
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLanguageService">
            <summary>Alternate name for Les2LanguageService (will change to Les3LanguageService in the future)</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2Printer">
            <summary>Prints a Loyc tree in LES (Loyc Expression Syntax) format.</summary>
            <remarks>Unless otherwise noted, the default value of all options is false.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Printer.Print(Loyc.Syntax.ILNode,Loyc.Syntax.Precedence,System.String)">
            <summary>Top-level non-static printing method</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Printer.StartStmt">
            <summary>Context: beginning of main expression (potential superexpression)</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2Printer.StartSubexpr">
            <summary>Context: beginning of subexpression (potential superexpression)</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les2Printer.IsNormalIdentifier(Loyc.Symbol)">
            <summary>Returns true if the given symbol can be printed as a 
            normal identifier, without an "@" prefix. Note: identifiers 
            starting with "#" still count as normal; call <see cref="P:Loyc.Syntax.LNode.HasSpecialName"/> 
            to detect this.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.Les2PrinterOptions">
            <summary>Options to control the way Loyc trees are printed by <see cref="T:Loyc.Syntax.Les.Les2Printer"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.AllowChangeParentheses">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list [] to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * @+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a slightly different tree (the parenthesis
            add the trivia attribute <c>%inParens</c>.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.PrintTriviaExplicitly">
            <summary>Causes comments and spaces to be printed as attributes in order 
            to ensure faithful round-trip parsing. By default, only "raw text" and
            unrecognized trivia is printed this way. Note: <c>%inParens</c> is 
            always printed as parentheses, and <see cref="P:Loyc.Syntax.ILNodePrinterOptions.OmitUnknownTrivia"/> 
            has no effect when this flag is true.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.OmitMissingArguments">
            <summary>When an argument to a method or macro has the value <c>@``</c>,
            it will be omitted completely if this flag is set.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaNewline"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.QuoteUnprintableLiterals">
            <summary>When the printer encounters an unprintable literal, it calls
            Value.ToString(). When this flag is set, the string is placed in double
            quotes; when this flag is clear, it is printed as raw text.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.Les2PrinterOptions.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpacesBetweenAppendedStatements">
            <summary>Whether to add a space between multiple statements printed on
            one line (initial value: true).</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpaceAroundInfixStopPrecedence">
            <summary>The printer avoids printing spaces around infix (binary) 
            operators that have the specified precedence or higher.</summary>
            <seealso cref="T:Loyc.Syntax.Les.LesPrecedence"/>
        </member>
        <member name="F:Loyc.Syntax.Les.Les2PrinterOptions.SpaceAfterPrefixStopPrecedence">
            <summary>The printer avoids printing spaces after prefix operators 
            that have the specified precedence or higher.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.INodePrinterWriter">
            <summary>This interface is implemented by helper objects that handle the 
            low-level details of node printing. It is used by <see cref="T:Loyc.Syntax.Les.Les2Printer"/>.</summary>
            <remarks>Specifically, INodePrinterWriter objects are in charge of how much
            to indent lines of code, and ensuring that there are spaces between tokens
            whenever omitting a space would screw up parsing.
            <para/>
            Although this interface is also used by EC#, I've kept it in the 
            Les namespace because I'm not yet confident that it's a <i>good</i> design 
            for arbitrary languages.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.INodePrinterWriter.Target">
            <summary>Gets the object being written to (TextWriter or StringBuilder)</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.INodePrinterWriter.Reset">
            <summary>Called when a new, separate printing operation begins.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.NodePrinterWriterBase">
            <summary>Abstract base class for <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>. Has an
            protected <c>_indentLevel</c> field that is increased by Indent() and 
            decreased by Dedent().</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesPrecedence">
             <summary>Contains <see cref="T:Loyc.Syntax.Precedence"/> objects that represent the 
             precedence levels of LES.</summary>
             <remarks>
             In LES, the precedence of an operator is decided based simply on the text 
             of the operator. The precedence of each one-character operator is 
             predefined; the precedence of any operator with two or more characters 
             is decided based on the first and last characters (according to
             the rules below). Other characters, if any, do not affect precedence.
             <para/>
             The LES precedence table mostly matches popular programming languages,
             i.e. those in the C family.
             <para/>
             An operator consists of a sequence of the following characters:
             <pre>
                ~ ! % ^ * - + = | &lt; > / ? : . &amp;
             </pre>
             In addition, the $ character is allowed as the first character and, if
             present, it forces the operator to be interpreted as a prefix operator.
             <para/>
             LESv3 also has operators that start with a single quote, which can include
             both letters and punctuation (e.g. <c>'|foo|</c>). The quote itself is 
             ignored for the purpose of choosing precedence. LESv2 has <c>`backquoted`</c> 
             operators instead, whereas in LESv3 backquoted strings are simply 
             identifiers. 
             <para/>
             It is notable that the following punctuation cannot be used in operators:
             <ul>
             <li>"@" is used for multiple other purposes.</li>
             <li>"#" is conventionally used to mark "keywords" (although in LESv2, the 
             parser treats it like an underscore or a letter.)</li>
             <li>"," and ";" are separators, so for example, "?,!" is parsed as three 
             separate tokens.</li>
             <li>The backslash "\" is reserved for future use.</li>
             </ul>
             <para/>
             The following table shows all the precedence levels and associativities
             of the "built-in" LES operators, except a couple of special operators such
             as the "lambda" operator =>, whose precedence is different on the left side 
             than on the right side. Each precedence level has a name, which corresponds 
             to a static field of this class. All binary operators are left-associative 
             unless otherwise specified.
             <ol>
             <li>Substitute: prefix $ . : (note: prefix-dot is not allowed in LES3)</li>
             <li>Primary: binary . =:, generic arguments List!(int), suffix ++ --, method calls f(x), indexers a[i]</li>
             <li>NullDot: binary ?. :: (in LESv2, :: is NullDot, in LESv3 it's Primary)</li>
             <li>DoubleBang: binary right-associative !!</li>
             <li>Prefix: prefix ~ ! % ^ * / - + &amp; `backtick` (LESv2 only)</li>
             <li>Power: binary **</li>
             <li>Multiply: binary * / % \ >> &lt;&lt;</li>
             <li>Add: binary + -</li>
             <li>Arrow: binary right-associative -> &lt;-</li>
             <li>PrefixDots: prefix ..</li>
             <li>Range: binary right-associative ..</li>
             <li>Compare: binary != == >= > &lt; &lt;=</li>
             <li>And: binary &amp;&amp;</li>
             <li>Or: binary || ^^</li>
             <li>IfElse: binary right-associative ? :</li>
             <li>LowerKeyword: a lowercase keyword</li>
             <li>PrefixOr: |</li>
             </ol>
             Not listed in table: binary <c>=> ~ = ?? >> ^ | &amp; &lt;&lt; </c>; prefix <c>? = > &lt;</c>;
             non-lowercase keywords.
             <para/>
             Notice that the precedence of an operator depends on how it is used. The 
             prefix operator <c>-</c> has higher precedence than the binary operator 
             <c>-</c>, so for example <c>- y * z</c> is parsed as <c>(- y) * z</c>, 
             while <c>x - y * z</c> is parsed as <c>x - (y * z)</c>.
             <para/>
             Programmers often use the shift operators <c>>></c> and <c>&lt;&lt;</c> 
             in place of multiplication or division, so their <i>natural</i> precedence
             is the same as <c>*</c> and <c>/</c>. However, traditionally the C
             family of languages confusingly give the shift operators a precedence 
             below <c>+</c>. Therefore, LES does not allow mixing of shift operators
             with <c>+ - * /</c>; <c>a >> b + c</c> should produce a parse error.
             This is called immiscibility as explained in the documentation of 
             <see cref="T:Loyc.Syntax.Precedence"/>. Parsing may still complete, but the exact 
             output tree is unspecified (may be <c>(a >> b) + c</c> or 
             <c>a >> (b + c)</c>).
             <para/>
             Likewise, the bitwise <c>^ | &amp;</c> operators cannot be mixed with
             comparison operators as in <c>a | 1 == 3</c>.
             <para/>
             The Lambda operator =>, which is right-associative, has a precedence 
             level above Multiply on the left side, but below Assign on the right 
             side. For example, the expression <c>a = b => c = d</c> is parsed as 
             <c>a = (b => (c = d))</c>, and similarly <c>a + b => c + d</c> is parsed 
             as <c>a + (b => (c + d))</c>, but <c>a ** b => c ** d</c> is parsed
             <c>(a ** b) => (c ** d)</c>. The idea of two different precedences on the
             two sides of an operator may seem strange; see the documentation of 
             <see cref="T:Loyc.Syntax.Precedence"/> for more explanation.
             <para/>
             Similarly, all assignment operators (including compound assignments like
             +=) have a high precedence on the left side and low precedence on the 
             right. This decision was made for WebAssembly, in which an expression like
             <c>2 * i32_store[$f(),4] = 3 * $g()</c> is best parsed as 
             <c>2 * (i32_store[$f(),4] = (3 * $g()))</c> (NOTE: this example will 
             surely be wrong by the time Wasm is released).
             <para/>
             As a nod to functional languages, the arrow operator "->" is right-
             associative and has a precedence below '*' so that <c>int * int -> int</c>
             parses as <c>(int * int) -> int</c> rather than <c>int * (int -> int)</c> 
             as in the C family of languages.
             <para/>
             Some operators like <c>'this-one</c> do not begin with punctuation. These
             "keyword operators" must be used as binary operators. They either start
             with a lowercase letter or they don't. If they do start with a lowercase
             letter, their precedence is LowerKeyword, which is very low, below 
             assignment, so that <c>a = b 'then x = y</c> parses like 
             <c>(a = b) 'then (x = y)</c>.
             <para/>
             If they do not start with a lowercase letter (as in <c>'Foo</c> or 
             <c>'123</c>) then they have an indeterminate precedence, below power
             (**) but above comparison (==). This means that an operator like 'XOR
             or 'Mod cannot be mixed with operators of precedence Multiply, Add, 
             Arrow, AndBits, OrBits, OrIfNull, PrefixDots, and Range operators.
             Mixing operators illegally (e.g. <c>x 'Mod y + z</c>) will produce a 
             parse error.
             <para/>
             After constructing an initial table based on common operators from other
             languages, I noticed that 
             <ul>
             <li>None of the high-precedence operators were right-associative, so I 
             added the !! operator to "fill in the gap".</li>
             <li>There were no prefix operators with low precedence, so I added ".." 
             whose precedence is just above binary "..", and "|" which has a precedence 
             lower than anything except attributes (this "operator" is inspired by
             Nemerle, which uses "|" in pattern matching and variants.)</li>
             </ul>
             I also wanted to have a little "room to grow"--to defer the precedence 
             decision to a future time for some operators. So the precedence of the 
             binary operator ~ has a range of operators with which it cannot be
             mixed, the same range as for uppercase operators without punctuation;
             for example, <c>x ~ y + z</c> is invalid but <c>x ~ y == z</c> is allowed.
             <para/>
             The operators <c>\ ? = > &lt;</c> cannot be used as prefix operators.
             <para/>
             The way that low-precedence prefix operators are parsed deserves some 
             discussion... TODO.
             <para/>
             Most operators can have two roles. Most operators can either be 
             binary operators or prefix operators; for example, <c>!*!</c> is a 
             binary operator in <c>x !*! y</c> but a prefix operator in <c>x + !*! y</c>.
             <para/>
             The operators <c>++ --</c> also have two roles, but different roles: 
             they can be either prefix or suffix operators, but not binary operators.
             For example, <c>-*-</c> is a suffix operator in <c>x -*- + y</c> and a 
             prefix operator in <c>x + -*- y</c>. Please note that <c>x -*- y</c> is 
             ambiguous (it could be parsed as either of two superexpressions, 
             <c>(x -*-) (y)</c> or <c>(x) (-*- y)</c>) and it is illegal.
             <para/>
             Operators that start with $ can only be prefix operators (not binary or 
             suffix). Having only a single role makes these operators unambiguous 
             inside superexpressions (LESv2) or with juxtaposition (LESv3).
             <para/>
             An operator cannot have all three roles (suffix, prefix and binary); that 
             would be overly ambiguous. For example, if "-" could also be a suffix 
             operator then <c>x - + y</c> could be parsed as <c>(x -) + y</c> as well 
             as <c>x - (+ y)</c>. More subtly, LES does not define any operators that
             could take binary or suffix roles, because that would also be ambiguous. 
             For example, suppose <c>|?|</c> is a binary or suffix operator, but not a 
             prefix operator. Clearly <c>x |?| y</c> and <c>x |?| |?| y</c> are 
             unambiguous, but <c>x |?| + y</c> is ambiguous: it could be parsed as 
             <c>(x |?|) + y</c> or <c>x |?| (+ y)</c>. It turns out that a computer 
             language can contain operators that serve as binary and prefix operators, 
             OR it can contain operators that serve as binary and suffix operators, 
             but a language is ambiguous if it has both kinds of operators at the 
             same time.
            
             <h3>How to detect an operator's precedence</h3>
             
             To determine the precedence of any given operator, first you must
             decide, mainly based on the context in which the operator appears and the
             text of the operator, whether it is a prefix, binary, or suffix operator. 
             Suffix operators can only be derived from the operators <c>++, --</c>
             ("derived" means that you can add additional operator characters in the 
             middle, e.g. <c>+++</c> and <c>-%-</c> are can be prefix or suffix 
             operators.)
             <para/>
             If an operator starts with a single quote in LESv3 ('), the quote is not
             considered for the purpose of choosing precedence (rather, it is used to 
             allow letters and digits in the operator name).
             <para/>
             Next, if the operator is only one character, simply find it in the list
             of operators in the previous section to learn its precedence. If the 
             operator is two or more characters, take the first character A and the 
             and the last character Z, and of the following rules, use the <b>first</b>
             rule that applies:
             <ol>
             <li>If AZ is "!=" or "==", or if the operator is exactly two characters 
             long (ignoring the initial single quote) and equal to ">=", or "&lt;=",
             its precedence is Compare. This rule separates comparison operators from 
             assignment operators, so that ">>=" is different from ">=", and "===" 
             counts as a comparison operator.</li>
             <li>If it's an infix operator and Z is '=', the precedence is Assign.</li>
             <li>Look for an operator named AZ from the section above. If it is defined,
             the operator will have the same precedence. For example, binary <c>=|></c>
             has the same precedence as binary "=>".</li>
             <li>Otherwise, look for an entry in the table for Z. For example,
             binary "%+" has the same precedence as binary "+" and unary "-*" has
             the same precedence as unary "*".</li>
             <li>If the operator is not an infix operator, it is illegal
             (e.g. prefix ?? doesn't exist).</li>
             <li>If A is a lowercase letter, the precedence is LowerKeyword.</li>
             <li>Otherwise, the operator's precedence is Other.</li>
             </ol>
             The double-colon :: has the "wrong" precedence according to C# and C++
             rules; <c>a.b::c.d</c> is parsed <c>(a.b)::(c.d)</c> although it would 
             be parsed <c>((a.b)::c).d</c> in C# and C++. The change in precedence 
             allows double colon to be used for variable declarations in LeMP, as 
             in <c>x::System.Drawing.Point</c>. The lower precedence allows this
             to be parsed properly, but it sacrifices full fidelity with C#/C++.
             <para/>
             There are no ternary operators in LES. '?' and ':' are right-associative 
             binary operators, so <c>c ? a : b</c> is parsed as <c>c ? (a : b)</c>.
             The lack of an official ternary operator reduces the complexity of the
             parser.
             <para/>
             LES represents Loyc trees, which do not distinguish operators and 
             functions except by name; <c>x += y</c> is equivalent to the function 
             call <c>`'+=`(x, y)</c> in LESv3 (<c>@'+=(x, y)</c> in LESv2), and 
             the actual name of the function is <c>'+=</c>. Operators that do not
             start with a single quote in LES <b>do</b> start with a single quote
             in the final output (e.g. <c>2 + 2</c> is equivalent to <c>2 '+ 2</c>).
             There is an exception: While prefix ++ and -- are named <c>'++</c> and 
             <c>'--</c>, the suffix versions are named <c>'suf++</c> and 
             <c>'suf--</c> in the output tree. For LESv2 operators surrounded by 
             `backquotes`, the backquotes are not included in the output tree (e.g.
             <c>`sqrt` x</c> is equivalent to <c>sqrt(x)</c>).
             </remarks>
             <seealso cref="T:Loyc.Syntax.Precedence"/>
        </member>
        <member name="T:Loyc.Syntax.Les.Les3PrecedenceMap">
            <summary>This class's main job is to maintain a table of 
            <see cref="T:Loyc.Syntax.Precedence"/> values for LES operators. When you ask about a
            new operator, its precedence is chosen by this class and cached for 
            future reference.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.Reset">
            <summary>Forgets previously encountered operators to save memory.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.Find(Loyc.Syntax.OperatorShape,System.Object,System.Boolean)">
            <summary>Gets the precedence in LES of a prefix, suffix, or infix operator.</summary>
            <param name="shape">Specifies which precedence table and rules to use 
            (Prefix, Suffix or Infix). Note: when this is Suffix, "_" is not expected 
            to be part of the name in <c>op</c>, i.e. op should be a Symbol like "'++" 
            rather than "'_++" (see also <see cref="M:Loyc.Syntax.Les.Les3PrecedenceMap.ResemblesSuffixOperator(Loyc.Symbol,Loyc.Symbol@)"/>)</param>
            <param name="op">Parsed form of the operator. op must be a Symbol, but 
            the parameter has type object to avoid casting Token.Value in the parser.</param>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsOpChar(System.Char)">
            <summary>Returns true if this character is one of those that operators are normally made out of in LES.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsOpCharEx(System.Char)">
            <summary>Returns true if this character is one of those that can appear 
            in "extended" LESv3 operators that start with an apostrophe.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsNaturalOperator(Loyc.UString)">
            <summary>Returns true if the given Symbol can be printed as an operator 
            without escaping it in LESv2.</summary>
            <remarks>The parser should read something like <c>+/*</c> as an operator
            with three characters, rather than "+" and a comment, but the printer 
            is more conservative, so this function returns false in such a case.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsNaturalOperatorToken(Loyc.UString)">
            <summary>Like <see cref="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsNaturalOperator(Loyc.UString)"/>, but doesn't expect name[0] is apostrophe.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.IsExtendedOperatorToken(Loyc.UString)">
            <summary>Returns true if the given Symbol can ever be used as an "extended" 
            binary operator in LESv3.</summary>
            <remarks>A binary operator's length must be between 2 and 255, its name must
            start with an apostrophe, and each remaining character must be punctuation marks 
            from natural operators and/or characters from the set 
            {'#', '_', 'a'..'z', 'A'..'Z', '0'..'9', '$'}.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.ToSuffixOpName(System.Object)">
            <summary>Given a normal operator symbol like <c>(Symbol)"'++"</c>, gets
            the suffix form of the name, such as <c>(Symbol)"'suf++"</c>.</summary>
            <remarks>op must be a Symbol, but the parameter has type object to avoid casting Token.Value in the parser.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.Les3PrecedenceMap.ResemblesSuffixOperator(Loyc.Symbol,Loyc.Symbol@)">
            <summary>Decides whether the name resembles a suffix operator.</summary>
            <param name="name">Potential operator name to evaluate.</param>
            <param name="bareName">If the name begins with "'suf", this is the same name with
            "suf" removed, otherwise it is set to <c>name</c> itself. This output is 
            calculated even if the function returns false.</param>
            <remarks>This method doesn't verify that the operator IS a legal suffix 
            operator, just that it has the form of one.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.TokenExt">
            <summary>Provides the <c>Type()</c> extension method required by 
            <see cref="T:Loyc.Syntax.Lexing.Token"/> and the ToString(Token) method to express an LES token
            as a string, for tokens that contain sufficient information to do so.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.Type(Loyc.Syntax.Lexing.Token)">
            <summary>Converts <c>t.TypeInt</c> to <see cref="T:Loyc.Syntax.Les.TokenType"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.ToString(Loyc.Syntax.Lexing.Token,Loyc.Collections.ICharSource)">
            <summary>Expresses a token as a string, using LES printers for identifiers and literals.</summary>
            <remarks>Note that some Tokens do not contain enough information to
            reconstruct a useful token string, e.g. comment tokens do not store the 
            comment but merely contain the location of the comment in the source code.
            For performance reasons, a <see cref="T:Loyc.Syntax.Lexing.Token"/> does not have a reference 
            to its source file, so this method cannot return the original string.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseILexer`2">
            <summary>A version of <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> that implements 
            <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/>. You should use this base class if you want to 
            wrap your lexer in a postprocessor such as <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> 
            or <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>. It can also be used with the <see 
            cref="M:Loyc.Collections.EnumerableExt.Buffered``1(System.Collections.Generic.IEnumerator{``0})"/> extension method to help feed data to your parser.
            </summary>
            <remarks>
            Important: the derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after
            encountering a newline (CR/LF/CRLF), in order to keep the properties 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            See <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken"/>.
            <para/>
            Alternately, your lexer can borrow the newline parser built into the base
            class, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and will call 
            <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @{ '\r' '\n'? | '\n' };
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @{ (' '|'\t')* }; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
            <typeparam name="Token">The type of token that your lexer will produce,
            e.g. <see cref="T:Loyc.Syntax.Lexing.Token"/>.</typeparam>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab">
            <summary>Number of spaces per tab, for the purpose of computing 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>. Initial value: 4</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseILexer`2._current">
            <summary>The token that will be returned from the Current property.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel">
            <summary>Gets the number of spaces that were used to indent the current
            line, where a tab counts as rounding up to the next multiple of 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab"/> spaces.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>Compared to the base class version of this function, this 
            method also skips over the UTF BOM '\uFEFF', if present, and it measures
            the indentation of the first line (without skipping over it).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken">
            <summary>Scans the next token in the character stream and returns the
            token, or null when the end of the text is reached.</summary>
            <remarks>
            The derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after it
            advances past each newline (CR/LF/CRLF), in order to keep the 
            properties <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            This must be done even when the newline is encountered inside a comment
            or multi-line string. Note that the <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> rule 
            in the base class will call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you.
            <para/>
            Also, while returning, the derived class should set the <c>_current</c> 
            field to its own return value so that the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.Current"/> property
            works reliably.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.SupportDotIndents">
            <summary>The LES and EC# languages support "dot indents", which are 
            lines that start with a dot (.) followed by a tab or spaces. If you
            overload this method to return true, then <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            and <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)"/> will count dot indents as part of the 
            indentation at the beginning of each line; otherwise, only spaces and
            tabs will be counted.</summary>
            <remarks>
            A dot indent has the syntax <c>('.' ('\t' | ' '+))*</c>. This 
            indentation style is recognized only if a dot is the first character 
            on a line. Each pair of dot+(tab/spaces) prior to the first non-space 
            token is counted the same way as a tab character (\t). Dot indents are 
            useful for posting source code on "bad" blog software or forums that 
            do not preseve indentation.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            <param name="ignoreIndent">Causes this method not to measure the indent
            at the beginning of this line, and leave the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> unchanged. You may wish to set this flag 
            when a newline is encountered inside a multiline comment.</param>
            <param name="skipIndent">This method normally scans indentation after 
            the newline character, in order to update the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties. If this parameter is true, the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.InputPosition"/> will also be increased, skipping past
            those initial spaces.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.ScanIndent(System.Boolean)">
            <summary>Scans indentation at the beginning of a line and updates the
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> properties.
            This function is called automatically by <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>,
            but should be called manually on the very first line of the file.</summary>
            <remarks>Parameters are documented at <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)"/></remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenTree">
            <summary>A list of Token structures along with the <see cref="T:Loyc.Syntax.ISourceFile"/> 
            object that represents the source file that the tokens came from.</summary>
            <remarks>This class is called <c>TokenTree</c> because certain kinds of 
            tokens used by some parsers are formed into trees by using <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> 
            as the type of the <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> of certain tokens. Specifically,
            the LES and EC# parsers expect open-bracket and open-brace tokens ('(', 
            '[' and '{') to have a child <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> that contains all the 
            tokens within a pair of brackets or braces. Typically this tree is not 
            created directly by the lexer, but by a helper class (<see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>).
            <para/>
            Caution: this class is mutable, even though TokenTrees are sometimes stored
            in <see cref="T:Loyc.Syntax.LNode"/>s which are supposed to be immutable. Please do not
            modify token trees that are stored inside LNodes.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Clone">
            <summary>Gets a deep (recursive) clone of the token tree.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Equals(Loyc.Syntax.Lexing.TokenTree)">
            <summary>Compares the elements of the token tree for equality.</summary>
            <remarks>Because <see cref="T:Loyc.Syntax.LNode"/>s are compared by value and not by 
            reference, and LNodes can contain TokenTrees, TokenTrees should also be
            compared by value.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.ToLNodes">
            <summary>Converts this list of <see cref="T:Loyc.Syntax.Lexing.Token"/> to a list of <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <remarks>See <see cref="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)"/> for more information.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.TokenToLNode(Loyc.Syntax.Lexing.Token,Loyc.Syntax.ISourceFile)">
            <summary>Converts a <see cref="T:Loyc.Syntax.Lexing.Token"/> to a <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <param name="file">This becomes the <see cref="P:Loyc.Syntax.LNode.Source"/> property.</param>
            <remarks>If you really need to store tokens as LNodes, use this. Only
            the <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/>, not the TypeInt, is preserved. Identifiers 
            (where Kind==TokenKind.Id and Value is Symbol) are translated as Id 
            nodes; everything else is translated as a call, using the TokenKind as
            the <see cref="P:Loyc.Syntax.LNode.Name"/> and the value, if any, as parameters. For
            example, if it has been treeified with <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, the
            token list for <c>"Nodes".Substring(1, 3)</c> as parsed by LES might 
            translate to the LNode sequence <c>String("Nodes"), Dot(@@.), 
            Substring, LParam(Number(1), Separator(@@,), Number(3)), RParen()</c>.
            The <see cref="P:Loyc.Syntax.LNode.Range"/> will match the range of the token.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Flatten">
            <summary>Converts a token tree back to a plain list.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TriviaSaver">
            <summary>A lexer wrapper that saves whitespace tokens into a list (<see cref="P:Loyc.Syntax.Lexing.TriviaSaver.TriviaList"/>).</summary>
            <remarks>
            This wrapper filters out all whitespace tokens (where <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> is 
            <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>) and saves them in a list. It is typically used with 
            <seealso cref="T:Loyc.Syntax.StandardTriviaInjector"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TriviaSaver.#ctor(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},System.Int32)">
            <summary>Initializer.</summary>
            <param name="lexer">Lexer to wrap.</param>
            <param name="newlineTypeInt">In some languages, newlines are not considered 
            whitespace but they still need to be saved in the trivia list. If the 
            <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/> equals this value, the token is saved but NOT filtered out.</param>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>This class will not work correctly if the lexer does not implement 
            <see cref="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel"/> properly.
            <para/>
            This class is abstract because it doesn't know how to classify or create 
            tokens. The derived class must implement <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>,
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/>, <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)"/> and 
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)"/>. <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> is a 
            non-abstract version of this class based on <see cref="T:Loyc.Syntax.Lexing.Token"/> 
            structures, with several properties that can be customized.
            <para/>
            Creation of indent, dedent, and end-of-line tokens can be suppressed inside 
            brackets, i.e. () [] {}. This is accomplished by recognizing brackets inside
            your implementation of <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>.
            <para/>
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> can be placed in the pipeline before or after 
            this class; if it is placed afterward, anything between Indent and Dedent
            tokens will be made a child of the Indent token.
            <para/>
            Note: whitespace tokens (<see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace"/>) are passed 
            through and otherwise unprocessed.
            <para/>
            Note: EOL tokens are not generated for empty or comment lines, and are not 
            generated after a generated indent token, although they could be generated 
            after a pre-existing indent token that was already in the token stream, 
            unless that token is categorized as <see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket"/>.
            <para/>
            Partial dedents and unexpected indents, as in
            <code>
              if Condition:
                  print("Hello")
                print("Hello again")
              else:
                  print("Goodbye")
                    print("Goodbye again")
            </code>
            will cause an error message to be written to the <see cref="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink"/> 
            of the original lexer.
            <para/>
            Please see <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> for additional remarks and examples.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.#ctor(Loyc.Syntax.Lexing.ILexer{`0})">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer (either a raw lexer or an instance of another preprocessor such as <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.)</param>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket">
            <summary>An open bracket, inside of which indent triggers should be ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.CloseBracket">
            <summary>A close bracket, whch reverses the effect of an open bracket.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.IndentTrigger">
            <summary>This token may trigger an indentation token, with an unindent
            token to be generated later, when a line is encountered that is not 
            indented in comparison to this line.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace">
            <summary>A whitespace token, which should be passed though and 
            otherwise ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Other">
            <summary>None of the other categories apply to this token.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)">
            <summary>Gets the category of a token for the purposes of indent processing.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)">
            <summary>Returns a token to represent indentation, or null to suppress 
            generating an indent-dedent pair at this point.</summary>
            <param name="indentTrigger">The token that triggered this function call.</param>
            <param name="tokenAfterward">The token after the indent trigger, or NoValue at EOF.</param>
            <param name="newlineAfter">true if the next non-whitespace token after 
            <c>indentTrigger</c> is on a different line, or if EOF comes afterward.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)">
            <summary>Returns token(s) to represent un-indentation.</summary>
            <param name="tokenBeforeNewline">The last non-whitespace token before dedent</param>
            <param name="tokenAfterNewline">The first non-whitespace un-indented 
            token after the unindent, or NoValue at the end of the file. The 
            derived class is allowed to change this token, or delete it by 
            changing it to NoValue.</param>
            <remarks>This class considers the indented block to be "over" even if 
            this method returns no tokens.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})">
            <summary>Returns a token to represent the end of a line, or null to
            avoid generating such a token.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline was encountered.</param>
            <param name="tokenAfterNewline">First non-whitespace token after newline.</param>
            <param name="deltaIndent">Change of indentation after the newline, or 
            null if a dedent token is about to be inserted after the newline.</param>
            <remarks>This function is also called at end-of-file, unless there are 
            no tokens in the file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.IndentChangedUnexpectedly(`0,Loyc.Maybe{`0}@,System.Int32@)">
            <summary>A method that is called when the indent level changed without
            a corresponding indent trigger.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline.</param>
            <param name="tokenAfterNewline">First non-whitespace token after the newline.
            Though it's a <see cref="T:Loyc.Maybe`1"/>, it always has a value, but this 
            function can suppress its emission by setting it to NoValue.Value.</param>
            <param name="deltaIndent">Amount of unexpected indentation (positive or 
            negative). On return, this parameter holds the amount by which to change
            the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator`1.CurrentIndent"/>; the default implementation leaves this
            value unchanged, which means that subsequent lines will be expected to 
            be indented by the same (unexpected) amount.</param>
            <returns>true if <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/> should be called as 
            usual, or false to suppress EOL genertion. EOL can only be suppressed
            in case of an unexpected indent (<c>deltaIndent>0</c>), not an unindent.</returns>
            <remarks>The default implementation always returns true. It normally 
            writes an error message, but switches to a warning in case 
            <c>OuterIndents[OuterIndents.Count-1] == OuterIndents[OuterIndents.Count-2]</c>, 
            which this class interprets as a single unindent.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.IndexToMsgContext(`0)">
            <summary>Gets the context for use in error messages, which by convention is a <see cref="T:Loyc.Syntax.SourceRange"/>.</summary>
            <remarks>The base class uses Lexer.InputPosition as a fallback if the token doesn't implement ISimpleToken{int}.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>
            Suppose you use an <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken"/> and <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken"/> 
            that are equal to the token types you've chosen for <c>{ braces }</c> (e.g.  
            (<see cref="F:Loyc.Syntax.Lexing.TokenKind.LBrace"/> and <see cref="F:Loyc.Syntax.Lexing.TokenKind.RBrace"/>), the 
            only indent trigger is a colon (:), and you set <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> to 
            the token type you're using for semicolons. Then this class will convert
            the token stream from input such as
            <code>
            def Sqrt(value):
            	if value == 0: return 0
            	g = 0; bshft = Log2Floor(value) >> 1;
            	b = 1 &lt;&lt; bshft
            	do:
            		temp = (g + g + b) &lt;&lt; bshft
            		if value >= temp: g += b
            			value -= temp
            		b >>= 1
            	while (bshft-- > 0)
            	return g
            </code>
            to a token stream equivalent to
            <code>
            def Sqrt(value): {
            	if value == 0: { return 0;
            	} g = 0; bshft = Log2Floor(value) >> 1;
            	b = 1 &lt;&lt; bshft;
            	do: {
            		temp = (g + g + b) &lt;&lt; bshft
            		if value >= temp: { g += b;
            			value -= temp;
            		} b >>= 1;
            	} while (bshft-- > 0);
            	return g;
            }</code>
            That is, a semicolon is added to lines that don't already have one, open 
            braces are inserted right after colons, and semicolons are <i>not</i> added 
            right after opening braces.
            <para/>
            If multiple indents occur on a single line, as in
            <code>
            if x: if y:
                Foo(x, y)
            </code>
            The output will be like this:
            <code>
            if x: { if y: {
                Foo(x, y);
            }}
            </code>
            
            <h3>Configuration for Python</h3>
            
            Newlines generally represent the end of a statement, while colons mark 
            places where a "child" block is expected. Inside parenthesis, square 
            brackets, or braces, newlines are ignored:
            <code>
            	s = ("this is a pretty long string that I'd like "
            	  + " to continue writing on the next line")
            </code>
            And, inside brackets, indentation is ignored, so this is allowed:
            <code>
            if foo:
            	s = ("this is a pretty long string that I'd like "
            + " to continue writing on the next line")
            	print(s)
            </code>
            Note that if you don't use brackets, Python 3 doesn't try to figure out if 
            you "really" meant to continue a statement on the next line:
            <code>
            	# SyntaxError after '+': invalid syntax
            	s = "this is a pretty long string that I'd like " + 
            		" to continue writing on the next line"
            </code>
            Thus OpenBrackets and CloseBrackets should be <c>( [ {</c> and <c>) ] }</c>, 
            respectively. IndentType and DedentType should be synthetic Indent and 
            Dedent tokens, since curly braces have a different meaning (they define a 
            dictionary).
            <para/>
            In Python, it appears you can't write two "block" statements on one line, 
            as in this example:
            <code>
              if True: if True: print() # SyntaxError: invalid syntax
            </code>
            You're also not allowed to indent the next line if the block statement on
            the current line is followed by another statement:
            <code>
              if True: print('a')
                  print('b') # IndentationError: unexpected indent
            </code>
            But you can switch style in different branches:
            <code>
              if True:
                  print("t")
              else: print("f")
              try: print("t")
              except: 
                  print("e")
            </code>
            Also, although you can normally separate statements with semicolons:
            <code>
              print("hell", end=""); print("o")
            </code>
            You are not allowed to write this:
            <code>
              print("?"); if True: # SyntaxError: invalid syntax
                 print("t")
            </code>
            Considering these three facts, I would say that the colon should be 
            classified as an EOL indent trigger (EolIndentTriggers), and the parser 
            should 
            1. recognize non-block statements separately from block statements,
            2. expect a colon to be followed by either an indented block or a non-block 
               statement, but
            3. recognize a non-block "statement" as a <i>list</i> of statements 
               separated by semicolons, with an optional semicolon at the end.
            <para/>
            Now, Python doesn't allow a block statement without a <c>pass</c>, e.g.:
            <code>
              if cond: # "do nothing"
              return   # IndentationError: expected an indented block
            </code>
            I'm inclined to treat this as a special case to be detected in the parser.
            And although you can write a semicolon on a line by itself, you can't 
            write any of these lines:
            <code>
              if cond: ;         # SyntaxError: invalid syntax
              print(); ; print() # SyntaxError: invalid syntax
              ; ;                # SyntaxError: invalid syntax
            </code>
            My interpretation is that a semicolon <i>by itself</i> is treated as a block 
            statement (i.e. illegal in a non-block statement context). Since a semicolon
            is not treated the same way as a newline, the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> should 
            be a special token, not a semicolon.
            </remarks>
            <seealso cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1"/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator.#ctor(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},System.Int32[],System.Nullable{Loyc.Syntax.Lexing.Token},Loyc.Syntax.Lexing.Token,Loyc.Syntax.Lexing.Token)">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer</param>
            <param name="allIndentTriggers">A list of all token types that could trigger the insertion of an indentation token.</param>
            <param name="eolToken">Prototype token for end-statement markers inserted when
            newlines are encountered, or null to avoid generating such markers.</param>
            <param name="indentToken">Prototype token for indentation markers</param>
            <param name="dedentToken">Prototype token for un-indent markers</param>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator._eolIndentTriggers">
            <summary>A subset of <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/> that only take 
            effect at the end of a line.</summary>
            <remarks>If this list includes items that are not in 
            <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/>, they have no effect.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken">
            <summary>Gets or sets the prototype token for end-statement (a.k.a. 
            end-of-line) markers, cast to an integer as required by <see cref="T:Loyc.Syntax.Lexing.Token"/>. 
            Use <c>null</c> to avoid generating such markers.</summary>
            <remarks>Note: if the last token on a line has this same type, this 
            class will not generate an extra newline token.
            <para/>
            The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken">
            <summary>Gets or sets the prototype token for indentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken">
            <summary>Gets or sets the prototype token for unindentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter`1">
            <summary>Filters out tokens whose <c>Value</c> is <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter">
            <summary>Alias for <c>WhitespaceFilter{Token}</c></summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1">
            <summary>The recommended base class for lexers generated by LLLPG,
            when not using the <c>inputSource</c> option.</summary>
            <remarks>
            If you are using the <c>inputSource</c> and <c>inputClass</c> options of,
            LLLPG, use <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> instead. If you want to
            write a lexer that implements <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> (so it is compatible
            with postprocessors like <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> and 
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>), use <see cref="T:Loyc.Syntax.Lexing.BaseILexer`2"/> as 
            your base class instead.
            <para/>
            This class contains many methods required by LLLPG, such as 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.NewSet(System.Int32[])"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.LA(System.Int32)"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LA0"/>, 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Match(System.Collections.Generic.HashSet{System.Int32})"/>(...), and <see 
            cref="M:Loyc.Syntax.Lexing.BaseLexer`1.TryMatch(System.Collections.Generic.HashSet{System.Int32})"/>(...), along with a few properties that are not 
            used by LLLPG that you still might want to have around, such as 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.FileName"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.CharSource"/> and 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/>.
            <para/>
            It also implements the caching behavior for which <see cref="T:Loyc.Collections.ICharSource"/>
            was created. See the documentation of <see cref="T:Loyc.Collections.ICharSource"/> for more
            information.
            <para/>
            All lexers derived from BaseLexer should call <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/>
            at the end of their newline rule, in order to increment the current line
            number. Alternately, your lexer can borrow the newline parser built into 
            BaseLexer, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and calls 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @{ '\r' '\n'? | '\n' };
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @{ (' '|'\t')* }; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            <para/>
            By default, errors are handled by throwing <see cref="T:System.FormatException"/>.
            The recommended way to alter this behavior is to change the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/> property. For example, set it to 
            <see cref="F:Loyc.MessageSink.Console"/> to send errors to the console, or
            use <see cref="M:Loyc.MessageSink.FromDelegate(Loyc.WriteMessageFn,System.Func{Loyc.Severity,System.Boolean})"/> to provide a custom handler.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes BaseLexer.</summary>
            <param name="chars">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>
            See the constructor for documentation of the parameters.
            <para/>
            This method can be used to avoid memory allocations when you
            need to parse many small strings in a row. If that's your goal, you 
            should set the <c>newSourceFile</c> parameter to false if possible.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseLexer`1.LogExceptionErrorSink">
            <summary>Throws LogException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Default"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.Lexing.BaseLexer`1.LogExceptionErrorSink"/>, which throws
            an exception if an error occurs.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip">
            <summary>Increments InputPosition. Called by LLLPG when prediction 
            already verified the input (and caller doesn't save LA(0))</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber">
            <summary>Current line number. Starts at 1 for the first line, unless derived class changes it.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt">
            <summary>Index at which the current line started.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline">
            <summary>Default newline parser that matches '\n' or '\r' unconditionally.</summary>
            <remarks>
            You can use this implementation in an LLLPG lexer with "extern", like so:
            <c>extern rule Newline @{ '\r' + '\n'? | '\n' };</c>
            By using this implementation everywhere in the grammar in which a 
            newline is allowed (even inside comments and strings), you can ensure
            that <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> is called, so that the line number
            is updated properly.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Spaces">
            <summary>Skips past any spaces at the current position. Equivalent to
            <c>rule Spaces @[ (' '|'\t')* ]</c> in LLLPG.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String)">
            <summary>This method is called to handle errors that occur during lexing.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="message">An error message, not including the error location.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String,System.Object[])">
            <summary>This method is called to format and handle errors that occur 
            during lexing. The default implementation sends errors to <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/>, 
            which, by default, throws a <see cref="T:System.FormatException"/>.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="format">An error description with argument placeholders.</param>
            <param name="args">Arguments to insert into the error message.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.MatchError(System.Boolean,System.Collections.Generic.IList{System.Int32})">
            <summary>Handles an error that occurs during Match(), MatchExcept(), MatchRange() or MatchExceptRange()</summary>
            <param name="inverted">Set inversion flag. If true, then <c>expected</c> is actually a list of things that were NOT expected.</param>
            <param name="ranges">List of ranges of characters that were expected (or unexpected, if <c>inverted</c>)</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.RangesToString(System.Collections.Generic.IList{System.Int32})">
            <summary>Converts a list of character ranges to a string, e.g. for input
            list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <summary>Prints a character as a string, e.g. <c>'a' -> "'a'"</c>, with 
            the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer">
            <summary>Alias for <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILexer`1">
            <summary>A standard interface for lexers.</summary>
            <typeparam name="Token">Type of tokens produced by the lexer (usually
            <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.SourceFile">
            <summary>The file being lexed.</summary>
            <remarks>This property should never be null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.ILexer`1.NextToken">
            <summary>Scans the next token and returns information about it.</summary>
            <returns>The next token, or null at the end of the source file.</returns>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink">
            <summary>Event handler for errors.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel">
            <summary>Indentation level of the current line. This is updated after 
            scanning the first whitespaces on a new line, and may be reset to zero 
            when <see cref="M:Loyc.Syntax.Lexing.ILexer`1.NextToken"/> returns a newline.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.LineNumber">
            <summary>Current line number (1 for the first line).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.InputPosition">
            <summary>Current input position (an index into SourceFile.Text).</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerWrapper`1">
            <summary>A base class for wrappers that modify lexer behavior.
            Implements the ILexer interface, except for the NextToken() method.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerWrapper`1.NextToken">
            <summary>Returns the next (postprocessed) token. This method should set
            the <c>_current</c> field to the returned value.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgApi`3">
            <summary>For reference purposes, this interface is a list of the non-static 
            methods that LLLPG expects to be able to call when it is generating code. 
            LLLPG does not actually need lexers and parsers to implement this interface;
            they simply need to implement the same set of methods as this interface 
            contains.</summary>
            <typeparam name="Token">The return value of the Match methods. LLLPG does 
            not care and does not need to know what this type is. In lexers, these 
            methods typically return the character that was matched (i.e. int, because
            EOF is -1), and in parsers they should return the token that was matched.</typeparam>
            <typeparam name="MatchType">The data type of arguments to Match, 
            MatchExcept, TryMatch and TryMatchExcept. In lexers, MatchType is always 
            int. In parsers, by default, LLLPG generates code as though MatchType is 
            same as LaType, but one often uses int instead, e.g. because enums do not
            implement <see cref="T:System.IEquatable`1"/> as required by 
            <see cref="T:Loyc.Syntax.BaseParser`2"/>. you're using
            <see cref="T:Loyc.Syntax.BaseParser`2"/> with LaType=int token 
            type is an enum, which for some reason does not implement 
            IEquatable{T}. So, often, when using BaseParser{Token you need to use the matchType(int) 
            option to change MatchType to int.</typeparam>
            <typeparam name="LaType">The data type of LA0 and LA(i). This is always int 
            in lexers, but in parsers you can use the laType(...) option to change this 
            type.</typeparam>
            <seealso cref="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1"/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1">
            <summary>For reference purposes, this interface contains the non-static 
            methods that LLLPG expects lexers to implement. LLLPG does not actually 
            expect lexers to implement this interface; they simply need to implement 
            the same set of methods as this interface contains.</summary>
            <typeparam name="Token">The return value of the Match() methods, which is
            the input value (character) actually encountered in the stream. This type 
            is usually int.</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource`1">
            <summary>An implementation of the LLLPG Lexer API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/>.
            </remarks>
            <example>
            LLLPG(lexer(inputSource(src), inputClass(LexerSource))) {
            	static rule int ParseInt(string input) {
            		var src = (LexerSource&lt;UString>)input;
            		@[ (d:='0'..'9' {$result = $result * 10 + (d - '0');})+ ];
            	}
            }
            </example>
            <typeparam name="CharSrc">A class that implements ICharSource. In order
            to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes LexerSource.</summary>
            <param name="source">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Skip">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.AfterNewline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Newline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceWorkaround`1">
            <summary>This class only exists to work around a limitation of the C# language:
            "cannot change access modifiers when overriding 'protected' inherited member Error(...)".</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource">
            <summary>A synonym for <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceFile`1">
            <summary>Adds the <see cref="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)"/> method to <see cref="T:Loyc.Syntax.SourceFile"/>.</summary>
            <remarks>
            When implementing a lexer, the most efficient approach to building the list
            of line breaks is to save the location of each newline as it is encountered 
            while lexing, rather than doing a separate pass over the file just to find 
            line breaks. This class supports this optimization.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)">
            <summary>Allows a lexer to record the index of the character after 
            each line break, in the order they exist in the file or string.</summary>
            <param name="index">Index of the first character after the newline.</param>
            <remarks>
            A lexer is not required to call this method; if the lexer doesn't call 
            it, the list of line breaks (which is used to map indexes to line 
            numbers and vice versa) will be built on-demand when one calls methods
            such as <c>IndexToLine</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenListAsLexer">
            <summary>Adapter: converts <c>IEnumerable(Token)</c> to the <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> interface.</summary>
            <remarks>
            The LineNumber property is computed on-demand by the <see cref="T:Loyc.Syntax.ISourceFile"/> provided.
            <para/>
            TODO: IndentLevel, IndentString do not work.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.Token">
            <summary>
            A common token type recommended for Loyc languages that want to use 
            features such as token literals or the <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> class.
            </summary>
            <remarks>
            For performance reasons, a Token ought to be a structure rather than
            a class. But if Token is a struct, we have a conundrum: how do we support 
            tokens from different languages? (We can't use inheritance in structs.)
            <para/>
            Luckily, tokens in most languages are very similar. A four-word structure
            generally suffices:
            <ol>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/>: each language can use a different set of token types 
            represented by a different <c>enum</c>. All enums can be converted to 
            an integer, so <see cref="T:Loyc.Syntax.Lexing.Token"/> uses Int32 as the token type. In order
            to support DSLs via token literals (e.g. LLLPG is a DSL inside EC#), the
            TypeInt should be based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Value"/>: this can be any object. For literals, this should 
            be the actual value of the literal, for whitespace it should be 
            <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>, etc. See <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> for 
            the complete list.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.StartIndex"/>: location in the original source file where 
            the token starts.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Length"/>: length of the token in the source file (32 bits).</li>
            </ol>
            Since 64-bit platforms are very common, the Value is 64 bits, and padding
            increases the structure size from 16 bytes to 24. Given this reality, 
            it was decided to fill in the 4 bytes of padding with additional information:
            <ol>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Style"/>: 8 bits of style information, e.g. it can be used to
               mark whether integer literals use hexadecimal, binary or decimal format.</li>
            <li>TextValue range: some constructors create an "uninterpreted literal"
               which is able to keep track of two values: the text of a literal, obtainable
               by calling <see cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/>, plus a type marker returned
               from <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/> (uninterpreted literals do not use the Value 
               property). 16 bits of information enables the TextValue feature to work without
               memory allocation in many cases; see the documentation of the constructor 
               <see cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,Loyc.Symbol,System.Int32,System.Int32)"/> for more
               information about the purpose and usage of this feature.</li>
            </ol>
            To save space (and because .NET doesn't handle large structures well),
            tokens do not know what source file they came from and cannot convert 
            their location to a line number. For this reason, one should keep a
            reference to the <see cref="T:Loyc.Syntax.ISourceFile"/> separately. You can then call
            <c>SourceText(ISourceFile.Text)</c> to get the original source text, or 
            <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> to get the source line number.
            <para/>
            A generic token also cannot convert itself to a properly-formatted 
            string. The <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/> method does allow you to provide an optional
            reference to <see cref="T:Loyc.Collections.ICharSource"/> which allows the token to get its
            original text, and in any case you can call <see cref="M:Loyc.Syntax.Lexing.Token.SetToStringStrategy(System.Func{Loyc.Syntax.Lexing.Token,Loyc.Collections.ICharSource,System.String})"/>
            to control the method by which a token converts itself to a string.
            <para/>
            Fun fact: originally I planned to use <see cref="T:Loyc.Symbol"/> as the common 
            token type, because it is extensible and could nicely represent tokens in 
            all languages; unfortunately, Symbol may reduce parsing performance 
            because it cannot be used with the switch opcode (i.e. the switch 
            statement in C#), so I decided to indicate token types via integers instead.
            Each language should have, in the namespace of that language, an
            extension method <c>public static TokenType Type(this Token t)</c> that 
            converts the TypeInt to the enum type for that language.
            Optionally, the TokenType enum for your language can be based on 
            <see cref="T:Loyc.Syntax.Lexing.TokenKind"/> so that the <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/> property returns
            a meaningful value.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,System.Int32,Loyc.Syntax.NodeStyle,System.Object)">
            <summary>Initializes the Token structure.</summary>
            <param name="type">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/></param>
            <param name="startIndex">Value of <see cref="P:Loyc.Syntax.Lexing.Token.StartIndex"/></param>
            <param name="length">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Length"/></param>
            <param name="style">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Style"/></param>
            <param name="value">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Value"/></param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,System.Int32,System.Object)">
            <inheritdoc cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,System.Int32,Loyc.Syntax.NodeStyle,System.Object)"/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,Loyc.Symbol,System.Int32,System.Int32)">
            <summary>Initializes an "uninterpreted literal" token designed to store 
            two parts of a literal without allocating extra memory (see the Remarks 
            for details).
            </summary>
            <param name="type">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/></param>
            <param name="startIndex">Value of <see cref="P:Loyc.Syntax.Lexing.Token.StartIndex"/></param>
            <param name="sourceText">A substring of the token in the original source 
            file, such that <see cref="P:Loyc.Syntax.Lexing.Token.Length"/> will be <c>sourceText.Length</c> 
            and <c>sourceText.Substring(valueStart - startIndex, valueEnd - valueStart)</c> 
            will be returned from <see cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/>. For correct
            results, the <see cref="T:Loyc.Collections.ICharSource"/> passed to TextValue later needs 
            to represent the same string that was used to produce this parameter.</param>
            <param name="style">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Style"/></param>
            <param name="typeMarker">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/>.</param>
            <param name="substringStart">Index where the TextValue starts in the source 
            code; should be equal to or greater than startIndex.</param>
            <param name="substringEnd">Index where the TextValue ends in the source 
            code; should be equal to or less than startIndex + tokenText.Length.</param>
            <remarks>
            Literals in many languages can be broken into two textual parts: their 
            type and their value. For example, in some languages you can write 123.5f,
            where "f" indicates that the floating-point value has a size of 32 bits.
            C++ strings have up to three parts, as in <c>u"Hello"_UD</c>: <c>u</c>
            indicates the character type (u = 16-bit unicode) while <c>_UD</c> 
            indicates that the string should be interpreted in a user-defined way.
            In LES3, all literals have two parts: value text and a type marker. For 
            example, 123.5f has a text "123.5" and type marker "_f"; greeting"Hello" 
            has text "Hello" and type marker "greeting"; and a simple number like 123 
            has text "123" and type marker "_".
            <para/>
            This constructor allows you to represent up to two "values" in a single 
            token without necessarily allocating memory for them, even though Tokens 
            only contain a single heap reference. When calling this constructor, the 
            second value, called the "TextValue", must be a substring of the token's 
            original source text; for example given the token <c>"Hello"</c>, the 
            tokenizer would use <c>Hello</c> as the TextValue. Rather than allocating 
            a string "Hello" and storing it in the token, you can use this constructor 
            to record the fact that the string <c>Hello</c> begins one character after 
            the beginning of the token (<c>valueStart = 1</c>) and one character 
            before the end of the token (<c>valueEnd = startIndex + tokenText.Length - 1</c>).
            When using this contructor, the Token's <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> property 
            returns null; internally the value reference points to the type marker,
            which is returned from the <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/> property rather than
            Value.
            <para/>
            Since a Token does not have a reference to its own source file (<see 
            cref="T:Loyc.Syntax.ISourceFile"/>), the language parser will need to use the <see 
            cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/> method to retrieve the value text later.
            <para/>
            <see cref="T:Loyc.Syntax.Lexing.Token"/> is a small structure that allocates only 8 bits for 
            the offset between the TextValue and the beginning/end of the sourceText 
            (16 bits total). If the start offset is above 254, the TextValue is 
            combined with the <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/> in a heap object of type
            <see cref="T:System.Tuple`2"/>, but this is a hidden implementation 
            detail.
            <para/>
            For strings that contain escape sequences, such as "Hello\n", you may
            prefer to store a parsed version of the string in the Token. There is
            another constructor for this purpose, which always allocates memory:
            <see cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,System.Int32,Loyc.Syntax.NodeStyle,Loyc.Symbol,Loyc.UString)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,System.Int32,Loyc.Syntax.NodeStyle,Loyc.Symbol,Loyc.UString)">
            <summary>Initializes an "uninterpreted literal" token (see the Remarks).</summary>
            <param name="type">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/></param>
            <param name="startIndex">Value of <see cref="P:Loyc.Syntax.Lexing.Token.StartIndex"/></param>
            <param name="length">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Length"/></param>
            <param name="style">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Style"/>.</param>
            <param name="typeMarker">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/>.</param>
            <param name="textValue">Value returned from <see cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/>.</param>
            <remarks>
            As explained in the documentation of the other constructor 
            (<see cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,Loyc.Symbol,System.Int32,System.Int32)"/>,
            some literals have two parts which we call the TypeMarker and the 
            TextValue. Since the Token structure only contains a single heap 
            reference, this contructor combines TypeMarker with TextValue in a 
            heap object, but this is a hidden implementation detail; just use
            <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/> and <see cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/> to
            retrieve the values.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,System.Object,Loyc.UString)">
            <summary>This is the most general Token constructor. Depending on its 
            parameters, it will initialize either a simple token with a Value, or an 
            "uninterpreted literal" that has a TypeMarker and a TextValue.</summary>
            <param name="type">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/></param>
            <param name="startIndex">Value of <see cref="P:Loyc.Syntax.Lexing.Token.StartIndex"/></param>
            <param name="sourceText">A substring of the token in the original source 
              file (something returned from <see cref="M:Loyc.Collections.ICharSource.Slice(System.Int32,System.Int32)"/>),
              such that <see cref="P:Loyc.Syntax.Lexing.Token.Length"/> will be <c>sourceText.Length</c> 
              and <see cref="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)"/> will return this same string
              if it is correctly given the same <see cref="T:Loyc.Collections.ICharSource"/> object.</param>
            <param name="style">Value of <see cref="P:Loyc.Syntax.Lexing.Token.Style"/>.</param>
            <param name="valueOrTypeMarker">Value of <see cref="P:Loyc.Syntax.Lexing.Token.TypeMarker"/> if you 
              are creating an uninterpreted literal or <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> if you 
              are not (according to the textValue parameter.)</param>
            <param name="textValue">If this Token does NOT represent an 
              uninterpreted literal, this parameter must be default(UString).
              If this value is non-default, this parameter will become the value of 
              <see cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/> if that method is correctly given 
              the same <see cref="T:Loyc.Collections.ICharSource"/> object from which <c>sourceText</c> 
              was extracted.</param>
            <remarks>
            As explained in the documentation of the other constructor 
            (<see cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,Loyc.Symbol,System.Int32,System.Int32)"/>,
            some literals have two parts which we call the TypeMarker and the TextValue.
            This constructor is designed to be used when the TextValue is sometimes
            a substring of the source code and sometimes merely derived from the 
            source code. For example, given the literal "Hello", the correct 
            TextValue is the five characters <c>Hello</c>, but given the C literal
            "Hi!\n", you may wish to translate the escape characters in the lexer,
            and create a Token that refers to the four decoded characters 
            <c>Hi!\n</c> (where \n represents a newline) rather than the five 
            characters of <c>Hi!\n</c> in the original source code.
            <para/>
            This constructor uses memory intelligently. If <c>textValue</c> is a 
            substring of <c>sourceText</c>, it will avoid allocating memory for a 
            reference to <c>textValue</c> (the optimization is described in more 
            detail in the other constructor's documentation.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.TypeInt">
            <summary>Token type.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Kind">
            <summary>Token category. This value is only meaningful if the token type
            integers are based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>s. Token types for LES and 
            Enhanced C# are, indeed, based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.StartIndex">
            <summary>Location in the orginal source file where the token starts, or
            -1 for a synthetic token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Length">
            <summary>Length of the token in the source file, or 0 for a synthetic 
            or implied token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Value">
            <summary>The parsed value of the token, if this structure was initialized
            with one of the constructors that accepts a value.</summary>
            <remarks>Recommended ways to use this property:
            <ul>
            <li>For strings: the parsed value of the string (no quotes, escape 
                sequences removed), i.e. a boxed char or a string. A backquoted 
                string in EC#/LES is converted to a <see cref="T:Loyc.Symbol"/> because it 
                is a kind of operator.</li>
            <li>For numbers: the parsed value of the number (e.g. 4 => int, 
                4L => long, 4.0f => float)</li>
            <li>For identifiers: the parsed name of the identifier, as a Symbol 
                (e.g. x => x, @for => for, @`1+1` => <c>1+1</c>)</li>
            <li>For any keyword including AttrKeyword and TypeKeyword tokens: a 
                Symbol containing the name of the keyword, with "#" prefix</li>
            <li>For punctuation and operators: the text of the punctuation as a 
                Symbol.</li>
            <li>For openers (open paren, open brace, etc.): null for normal linear
                parsers. If the tokens have been processed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>,
                this will be a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>.</li>
            <li>For spaces and comments: for performance reasons, it is not 
                recommended to extract the text of whitespace from the source file; 
                instead, use <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/></li>
            <li>When no value is needed (because the Type() is enough): null</li>
            </ul>
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.TypeMarker">
            <summary>Gets the type marker stored in this token, if this token was 
            initialized with one of the constructors that accepts a type marker.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Children">
            <summary>Returns Value as TokenTree (null if not a TokenTree).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.IsUninterpretedLiteral">
            <summary>Indicates that the token was initialized with a pair of values
            (type marker and text value) representing an uninterpreted literal.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Style">
            <summary>8 bits of nonsemantic information about the token. The style 
            is used to distinguish hex literals from decimal literals, or triple-
            quoted strings from double-quoted strings.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.EndIndex">
            <summary>Returns StartIndex + Length.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.IsWhitespace">
            <summary>Returns true if Value == <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Is(System.Int32,System.Object)">
            <summary>Returns true if the specified type and value match this token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.ToStringStrategy">
            <summary>Gets or sets the strategy used by <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Range(Loyc.Syntax.ISourceFile)">
            <summary>Converts Token to SourceRange using <c>SourceRange.New(sourceFile, this)</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Range(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token})">
            <summary>Converts Token to SourceRange using <c>SourceRange.New(l.SourceFile, this)</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)">
            <summary>Gets the original source text for a token if available, under the 
            assumption that the specified source file correctly specifies where the
            token came from. If the token is synthetic, returns <see cref="F:Loyc.UString.Null"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)">
            <summary>Helps get the "text value" from tokens that used one of the 
            constructors designed to support this use case, e.g.
            <see cref="M:Loyc.Syntax.Lexing.Token.#ctor(System.Int32,System.Int32,Loyc.UString,Loyc.Syntax.NodeStyle,Loyc.Symbol,System.Int32,System.Int32)"/>.
            If one of the other constructors was used, this function returns the same
            value as <see cref="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)"/>.</summary>
            <param name="source">Original source code or lexer from which this token was derived.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token})">
            <inheritdoc cref="M:Loyc.Syntax.Lexing.Token.TextValue(Loyc.Collections.ICharSource)"/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToString">
            <summary>Reconstructs a string that represents the token, if possible.
            Does not work for whitespace and comments, because the value of these
            token types is stored in the original source file and for performance 
            reasons is not copied to the token.</summary>
            <remarks>
            This does <i>not</i> return the original source text; it uses the stringizer 
            in <see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/>, which can be overridden with language-
            specific behavior by calling <see cref="M:Loyc.Syntax.Lexing.Token.SetToStringStrategy(System.Func{Loyc.Syntax.Lexing.Token,Loyc.Collections.ICharSource,System.String})"/>.
            <para/>
            The returned string, in general, will not match the original
            token, since the <see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/> does not have access to
            the original source file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToString(Loyc.Collections.ICharSource)">
            <summary>Gets the original text of the token, if you provide a reference
            to the original source code text. Note: the method used to convert the
            token to a string can be overridden with <see cref="M:Loyc.Syntax.Lexing.Token.SetToStringStrategy(System.Func{Loyc.Syntax.Lexing.Token,Loyc.Collections.ICharSource,System.String})"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Equals(Loyc.Syntax.Lexing.Token)">
            <summary>Equality depends on TypeInt and Value, but not StartIndex and 
            Length (this is the same equality condition as <see cref="T:Loyc.Syntax.LNode"/>).</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceTag">
            <summary><see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/> can be used as the
            <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> of whitespace tokens, to make whitespace
            easy to filter out.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken`1">
            <summary>Basic information about a token as expected by <see cref="T:Loyc.Syntax.BaseParser`1"/>:
            a token <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/>, which is the type of a "word" in the program 
            (string, identifier, plus sign, etc.), a value (e.g. the name of an 
            identifier), and an index where the token starts in the source file.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type">
            <summary>The category of the token (integer, keyword, etc.) used as
            the primary value for identifying the token in a parser.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.StartIndex">
            <summary>Character index where the token starts in the source file.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken">
            <summary>Alias for <see cref="!:ISimpleToken&lt;int&gt;"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IToken`1">
            <summary>The methods of <see cref="T:Loyc.Syntax.Lexing.Token"/> in the form of an interface.</summary>
            <typeparam name="TT">Token Type: the data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (one often uses int).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IToken">
            <summary>Alias for <see cref="!:IToken&lt;int&gt;"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenKind">
            <summary>A list of token categories that most programming languages have.</summary>
            <remarks>
            Some Loyc languages will support the concept of a "token literal" which
            is a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>, and some DSLs will rely on these token 
            literals for input. However, tokens differ between different languages; 
            for instance the set of operators varies between languages. On the other 
            hand, most languages do have some concept of "an operator" and "an 
            identifier", and the TokenKind reflects this fact.
            <para/>
            When you are using <see cref="T:Loyc.Syntax.Lexing.Token"/> to represent tokens in your language,
            it is recommended to define every value of your "TokenType" enumeration in 
            terms of TokenKind using integer offsets, like this:
            <pre>
            enum MyTokenType {
                EOF         = TokenKind.Spaces,
                Id          = TokenKind.Id,
                IfKeyword   = TokenKind.OtherKeyword,
                ForKeyword  = TokenKind.OtherKeyword + 1,
                LoopKeyword = TokenKind.OtherKeyword + 2,
                ...
                MulOp   = TokenKind.Operator,
                AddOp   = TokenKind.Operator + 1,
                DivOp   = TokenKind.Operator + 2,
                DotOp   = TokenKind.Dot,
                ...
            }
            </pre>
            Using TokenKind is only important if you intend to support DSLs via token
            literals (e.g. LLLPG) in your language.
            <para/>
            A DSL that just needs simple tokens like "strings", "identifiers" and "dots" 
            can write a parser based on values of <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/> alone; if 
            it needs certain specific operators or "keywords" that do not have a 
            dedicated TokenKind, such as + and %, it can further check the Value of the 
            token; meanwhile, the host language put a global <see cref="T:Loyc.Symbol"/> 
            in the <see cref="P:Loyc.Syntax.Lexing.Token.Value"/> to represent operators, keywords and 
            identifiers.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Other">
            <summary>For token types not covered by other token kinds.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Comment">
            <summary>Single- and multi-line comments</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Id">
            <summary>Simple identifiers</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Literal">
            <summary>Literals, such as numbers and strings.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Dot">
            <summary>Scope operator (dot and dot-like ops such as :: in C++) </summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Assignment">
            <summary>Simple or compound assignment</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Operator">
            <summary>All operators except assignment, dot, or separators</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Separator">
            <summary>e.g. semicolon, comma (if not considered an operator)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.AttrKeyword">
            <summary>e.g. public, private, static, virtual</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.TypeKeyword">
            <summary>e.g. int, bool, double, void</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.OtherKeyword">
            <summary>e.g. sizeof, struct. Does not include literal keywords (true, false, null)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Spaces">
            <summary>Spaces, tabs, non-semantic newlines, and EOF</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.BracketFlag">
            <summary>Openers and closers all have this bit set.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.CloserFlag">
            <summary>Closers all have this bit set.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokensToTree">
            <summary>
            A preprocessor usually inserted between the lexer and parser that converts 
            a token list into a token tree. Everything inside brackets, parens or 
            braces is made a child of the open bracket.
            </summary>
            <remarks>
            The close bracketis not treated as one of the children of the opening bracket.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ILiteralValueProvider">
            <summary>The intention of this interface is that a <c>struct</c> implementing 
            it can be embedded inside a <see cref="T:Loyc.Syntax.LiteralNode"/> in order to lazily obtain
            the text of a literal, or even parse it lazily.</summary>
            <remarks>Each method here is given the value of <see cref="P:Loyc.Syntax.LNode.Range"/> so that 
            the provider has access to the original source code text.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ILiteralValueProvider.GetValue(Loyc.Syntax.SourceRange)">
            <summary><see cref="P:Loyc.Syntax.LNode.Value"/> returns whatever this returns.</summary>
        </member>
        <member name="M:Loyc.Syntax.ILiteralValueProvider.GetTextValue(Loyc.Syntax.SourceRange)">
            <summary><see cref="P:Loyc.Syntax.LNode.TextValue"/> returns whatever this returns.</summary>
        </member>
        <member name="M:Loyc.Syntax.ILiteralValueProvider.GetTypeMarker(Loyc.Syntax.SourceRange)">
            <summary><see cref="P:Loyc.Syntax.LNode.TypeMarker"/> returns whatever this returns.</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNodePrinter">
            <summary>This interface allows serializing <see cref="T:Loyc.Syntax.LNode"/> objects into the
            syntax of a particular programming language.</summary>
            <remarks>The ToString() method of an object that implements this interface should
            return the name of the programming language that it is able to print.</remarks>
            <seealso cref="T:Loyc.Syntax.LNodePrinter"/>
        </member>
        <member name="M:Loyc.Syntax.ILNodePrinter.Print(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes the specified syntax tree to a StringBuilder in the syntax supported by this object.</summary>
            <param name="node">A syntax tree to print.</param>
            <param name="target">An output buffer, to which output is appended.</param>
            <param name="sink">An object used to print warning and error messages. If 
            this is null, messages are sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="mode">Indicates the context in which the node(s) to be printed 
            should be understood (e.g. is it a statement or an expression?).</param>
            <param name="options">A set of options to control printer behavior. If null,
            an appropriate default set of options should be used. Some languages may
            support additional option interfaces beyond <see cref="T:Loyc.Syntax.ILNodePrinterOptions"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ILNodePrinter.Print(System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes a list of syntax trees to a StringBuilder in the syntax supported by this object.</summary>
            <param name="nodes">Syntax trees to print.</param>
            <param name="target">An output buffer, to which output is appended.</param>
            <param name="sink">An object used to print warning and error messages. If 
            this is null, messages are sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="mode">Indicates the context in which the node(s) to be printed 
            should be understood (e.g. is it a statement or an expression?).</param>
            <param name="options">A set of options to control printer behavior. If null,
            an appropriate default set of options should be used. Some languages may
            support additional option interfaces beyond <see cref="T:Loyc.Syntax.ILNodePrinterOptions"/>.</param>
            <remarks>Some implementations can simply call <see cref="M:Loyc.Syntax.LNodePrinter.PrintMultiple(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)"/>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinter">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.Print(Loyc.Syntax.ILNodePrinter,Loyc.Syntax.LNode,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes the specified syntax tree to a string in the 
            syntax supported by the specified <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.Print(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Serializes a list of syntax trees to a string in the 
            syntax supported by the specified <see cref="T:Loyc.Syntax.ILNodePrinter"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodePrinter.PrintMultiple(Loyc.Syntax.ILNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Converts a sequences of LNodes to strings, adding a line separator between each.</summary>
            <param name="printer">Printer to be used for each single LNode.</param>
            <remarks>The newline between two nodes is suppressed if the second 
            node has a <c>%appendStatement</c> attribute.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LiteralFromParser">
            <summary>This structure is typically created implicitly by
            <see cref="M:Loyc.Syntax.LNodeFactory.Literal(Loyc.Syntax.Lexing.Token,Loyc.Syntax.ILiteralParser)"/>. 
            It holds the value of a literal while being able to retrieve the unescaped text 
            of that literal from the source code.</summary>
            <remarks>This type is a bit smaller than <see cref="T:Loyc.Syntax.LiteralValue"/> because
            it doesn't hold a reference to the source text; instead it shares the reference 
            to the source file that is already stored in the <see cref="T:Loyc.Syntax.LNode"/> in which 
            it is embedded.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LiteralFromParser.#ctor(System.Int32,System.Int32,Loyc.Symbol)">
            <summary>This constructor is meant for the case where the Value should
            simply be the boxed return value from <see cref="M:Loyc.Syntax.LiteralFromParser.GetTextValue(Loyc.Syntax.SourceRange)"/> (i.e. 
            <see cref="P:Loyc.Syntax.LNode.TextValue"/>). To save memory, the Value (of type
            <see cref="T:Loyc.UString"/>) is not generated until it is requested.</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralValue">
            <summary>Bundles the optional original text of a value with an optional in-memory 
            form of it; see remarks at <see cref="T:Loyc.Syntax.ILiteralValue"/>.
            This struct can also be turned into an LNode by calling 
            <see cref="M:Loyc.Syntax.LNode.Literal``1(Loyc.Syntax.SourceRange,``0,Loyc.Syntax.NodeStyle)"/>.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.LNodeList">
            <summary>A list of non-null references to LNode.</summary>
            <remarks>
            Users of Loyc trees previously needed to refer directly to <see cref="T:Loyc.Collections.VList`1"/> so they 
            were dependent on which list implementation is used, which is unfortunate. It is nice to have 
            the freedom of a <i>struct</i> for the node list so that implementations like VList are possible,
            but to refer to VList by name prevents easily changing list representations.
            <para/>
            In the future we'll probably move away from VList as a representation, mainly so that 
            Loyc.Syntax.dll does not need to take a dependency on Loyc.Collections.dll. This struct
            will aid the transition.
            <para/>
            For now, there are implicit conversions between <see cref="T:Loyc.Collections.VList`1"/> and LNodeList. These
            will be removed eventually.
            <para/>
            A disadvantage of this approach is that C# does not support user-defined conversions to 
            interfaces. Therefore, conversion to IReadOnlyList will box the wrapper instead of the 
            underlying implementation. Ugh.
            <para/>
            This change is issue #100: https://github.com/qwertie/ecsharp/issues/100
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.SmartSelect(System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode})">
            <summary>Maps a list to another list of the same length.</summary>
            <param name="map">A function that transforms each item in the list.</param>
            <returns>The list after the map function is applied to each item. The 
            original list is not modified.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map
            doesn't do anything. If the map function returns the first N items
            unmodified, those N items are typically not copied, but shared between
            the existing list and the new one. This is useful for functional code
            that often processes a list without modifying it at all.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.SmartSelectMany(System.Func{Loyc.Syntax.LNode,System.Collections.Generic.IReadOnlyList{Loyc.Syntax.LNode}})">
            <summary>Maps a list to another list by concatenating the outputs of a mapping function.</summary>
            <param name="map">A function that transforms each item in the list to a list of items.</param>
            <returns>A list that contains all the items returned from `map`.</returns>
            <remarks>
            This method is called "Smart" because of what happens if the map returns
            the same list again. If, for the first N items, the `map` returns a 
            list of length 1, and that one item is the same item that was passed 
            in, then those N items are typically not copied, but shared between
            the existing list and the new one. This is useful for functional code
            that often processes a list without modifying it at all.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.SmartWhere(System.Func{Loyc.Syntax.LNode,System.Boolean})">
            <summary>Filters the list, returning the same list if the filter function returns true for every item.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.WhereSelect(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}})">
            <summary>Filters and maps a list with a user-defined function.</summary>
            <param name="filter">A function that chooses which items to include
            in a new list, and what to change them to.</param>
            <returns>The list after filtering has been applied. The original list
            structure is not modified.</returns>
            <remarks>
            This is a smart function. If the filter does not modify the first N 
            items it is passed (which are the last items in a FVList), those N items 
            are typically not copied, but shared between the existing list and the 
            new one.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.op_Equality(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)">
            <summary>Returns whether the two list references are the same.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeList.op_Inequality(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)">
            <summary>Returns whether the two list references are different.
            Does not compare the contents of the lists.</summary>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinterOptions">
            <summary>A concrete class that users can pass to an <see cref="T:Loyc.Syntax.LNodePrinter"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.UninterpretedLiteral">
            <summary>A simple implementation of <see cref="T:Loyc.Syntax.IUninterpretedLiteral"/> which
            can also be turned into an LNode by calling 
            <see cref="M:Loyc.Syntax.LNode.Literal``1(Loyc.Syntax.SourceRange,``0,Loyc.Syntax.NodeStyle)"/>.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class design. You 
            should use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.#ctor(Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes the base class.</summary>
            <param name="file">A source file object that will be returned by the 
            <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> property. By default, this object is used to 
            get the file name, line number and column number shown in parser errors. 
            If your lexer uses <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
            you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
            property. The <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> property (in this class) will 
            return this value. If this parameter is null, then by default, error 
            messages will only show the character index instead of the file, line 
            number and column number.</param>
            <param name="startIndex">The initial value of <see cref="P:Loyc.Syntax.BaseParser`2.InputPosition"/>.</param>
        </member>
        <member name="F:Loyc.Syntax.BaseParser`2.LogExceptionErrorSink">
            <summary>Throws LogException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Default"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.BaseParser`2.LogExceptionErrorSink"/>, which throws
            an exception if an error occurs.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.SourceFile">
            <summary>The <see cref="T:Loyc.Syntax.ISourceFile"/> object that was provided to the constructor, if any.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LT0">
            <summary>Next token to parse (cached; is set to LT(0) whenever InputPosition is changed).</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.InputPosition">
            <summary>Current position of the next token to be parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.EofInt">
            <summary>Returns the value used for EOF (normally 0)</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LA0Int">
            <summary>Returns the token type of _lt0 (normally _lt0.TypeInt)</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LT(System.Int32)">
            <summary>Returns the token at lookahead i (e.g. <c>Source[InputPosition + i]</c>
            if the tokens come from a list called Source) </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)">
            <summary>Converts a lookahead token index to a character index (used 
            for error reporting).</summary>
            <remarks>
            The default implementation does this by trying to cast 
            <c>LT(lookaheadIndex)</c> to <c>ISimpleToken{MatchType}</c>. Returns -1
            on failure.
            <para/>
            The <c>StartIndex</c> reported by an EOF token is assumed not 
            to be trustworthy (since it is allowed to be a "dummy" token): this 
            method will ensure that the character index returned for EOF is at least 
            as large as <c>SourceFile.Text.Count</c> if a <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> was 
            provided, or, otherwise, at least as large as the last token in the file, 
            by scanning backward to find the last token in the file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToMsgContext(System.Int32)">
            <summary>Converts a lookahead token index to a <see cref="T:Loyc.Syntax.SourceRange"/>
            (or to a string if <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> was initialized to null.)</summary>
            <remarks>The base class can only return a zero-width SourceRange.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)">
            <summary>Records an error or throws an exception.</summary>
            <param name="lookaheadIndex">Location of the error relative to the
            current <c>InputPosition</c>. When called by BaseParser, lookaheadIndex 
            is always equal to 0.</param>
            <remarks>
            The default implementation throws a <see cref="T:System.FormatException"/>.
            When overriding this method, you can convert the lookaheadIndex
            to a <see cref="T:Loyc.Syntax.SourcePos"/> using the expression
            <c>SourceFile.IndexToLine(LT(lookaheadIndex).StartIndex)</c>. This only
            works if an <c>ISourceFile</c> object was provided to the constructor of 
            this class, and <c>Token</c> implements <see cref="T:Loyc.Syntax.Lexing.ISimpleToken"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String,System.Object[])">
            <inheritdoc cref="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)"/>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.MatchError(System.Boolean,System.Collections.Generic.IEnumerable{`1})">
            <summary>Handles an error that occurs during Match() or MatchExcept()</summary>
            <param name="inverted">Set inversion flag. If true, then <c>expected</c> is actually a list of things that were NOT expected.</param>
            <param name="expected">List of items that were expected (or unexpected, if <c>inverted</c>)</param>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class. You should 
            use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead. This class is
            now an alias for BaseParser{Token,int}.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`3">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            (Potentially also useful for parsers written by hand.)
            </summary>
            <remarks>
            The compiler will ensure that you use this base class correctly. All you 
            have to do is call the base class constructor and override the abstract 
            method <see cref="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)"/>.
            <para/>
            This version of BaseParserForList has <c>List</c> (a token list) as a 
            generic parameter. Compared to using <c>IList{Token}</c> directly, this 
            can increase performance in case the <c>List</c> is a value type (e.g. 
            <c>InternalList&lt;Token></c>).
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class assumes that it will 
            never be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property. Unfortunately,
            <c>MatchType</c> cannot be an enum because, strangely, an enum does not 
            implement <see cref="T:System.IEquatable`1"/>. So if your token type is an enum, as
            it usually is, set this to <c>int</c> and use <c>matchType: int</c> when you 
            invoke LLLPG: <c>LLLPG(parser(matchType: int, laType: TokenEnum));</c>.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,System.Func{`0,`0},`1,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="list">A list of tokens that the derived class will parse.</param>
            <param name="getEofToken">This is either a token value to return when the 
              input position reaches the end of the token list, or a function that
              computes a "synthetic" EOF token given the final token in the file. 
              Ideally the <c>StartIndex</c> of the EOF token contains the position of 
              EOF for proper error handling; if your grammar has expects a certain 
              token, it's usually possible to receive a different token or EOF instead,
              which may not have a valid Value but should have correct position info so 
              that you can construct your syntax tree. If your token stream is lazy-
              loaded then you don't know the EOF position yet, which is why you may
              wish to pass a method instead of just a token.
              <para/>
              In any case, <see cref="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)"/> does 
              not trust this value, and will ensure that the character index returned 
              for EOF is at least as large as the character index of the last token in 
              the file, so that error messages involving EOF won't be overly 
              inaccurate.</param>
            <param name="eof">The value of the EOF property used by LLLPG to detect EOF.</param>
            <param name="file">A source file object that will be returned by the 
              <see cref="T:Loyc.Syntax.SourceFile"/> property. By default, this object is used to 
              get the file name, line number and column number shown in parser errors. 
              If your lexer uses <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
              you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
              property. The <see cref="T:Loyc.Syntax.SourceFile"/> property (in this class) will 
              return this value. If this parameter is null, then by default, error 
              messages will only show the character index instead of the file, line 
              number and column number.</param>
            <param name="startIndex">The initial index from which to start reading
              tokens from the list (normally 0).</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheritdoc cref="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,System.Func{`0,`0},`1,Loyc.Syntax.ISourceFile,System.Int32)"/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>See the constructor for documentation of the parameters.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,System.Func{`0,`0},`1,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>See the constructor for documentation of the parameters.</remarks>
        </member>
        <member name="P:Loyc.Syntax.BaseParserForList`3.TokenList">
            <summary>The IList{Token} that was provided to the constructor, if any.</summary>
            <remarks>Note: if you are starting to parse a new source file, you should call 
            <see cref="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)"/> instead of setting this property.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Down(`2)">
            <summary>Switches to parsing the specified token list at position zero
            (typically the value of <see cref="P:Loyc.Syntax.Lexing.Token.Children"/> 
            in a token tree produced by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.) The original 
            token list and the original <see cref="P:Loyc.Syntax.BaseParserForList`3.InputPosition"/> are placed on a 
            stack, so you can restore the old list by calling <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/>.</summary>
            <returns>True if successful, false if <c>children</c> is null.</returns>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up">
            <summary>Returns to the old token list saved by <see cref="M:Loyc.Syntax.BaseParserForList`3.Down(`2)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up``1(``0)">
            <summary>Calls <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/> and returns <c>value</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers reads tokens from <see cref="T:System.Collections.Generic.IList`1"/>,
            but you can also pass an <see cref="T:System.Collections.Generic.IEnumerable`1"/> or 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> to the constructor and it will 
            convert it to a list, lazily, using <see cref="T:Loyc.Collections.BufferedSequence`1"/>.
            <para/>
            Please see additional documentation in the base class.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IList{`0},System.Func{`0,`0},`1,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0},`1,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers simply requires an enumerator to work,
            and it has a small buffer to hold lookahead tokens. Old tokens are 
            forgotten, so this base class does not support backtracking (i.e. syntactic 
            predicates), but it can save memory. Please use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> 
            if your input sequence comes in the form of a list.
            <para/>
            This version of BaseParser has Enumerator as a generic parameter. Compared 
            to using IEnumerator{Token} directly, this can increase performance in case 
            Enumerator is a value type (e.g. <c>List&lt;Token>.Enumerator</c>).
            <para/>
            (I wrote this class by mistake... I actually forgot about backtracking!)
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.#ctor(`1,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="sequence">A list of tokens to be parsed.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list.</param>
            <param name="file">A source file object that will be returned by the <see cref="T:Loyc.Syntax.SourceFile"/>
            property. By default, this object is used to get the file name, line 
            number and column number shown in parser errors. If you are using 
            <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/>, you can get this object from the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property. The <see cref="T:Loyc.Syntax.SourceFile"/>.
            property (in this class) will return this value. It can be null, which
            means that default error messages will show the character index instead
            of the file, line number and column number.</param>
            <param name="startIndex">The initial value of the InputPosition property.
            This is informational only, and has no effect on the behavior of this 
            class.</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.LT(System.Int32)">
            <summary>Returns the Token at lookahead i, where 0 is the next token.
            This class does not support negative lookahead because old tokens from 
            the IEnumerator are discarded.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.ToString(System.Int32)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserNoBacktracking`2.InputPosition">
            <summary>Cumulative index of the next token to be parsed.</summary>
            <remarks>This class doesn't care what the absolute InputPosition is, 
            since it reads from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>. This property
            is constrained to always increase, since old tokens are forgotten.</remarks>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <seealso cref="T:Loyc.Syntax.BaseParserNoBacktracking`2"/>
        </member>
        <member name="T:Loyc.Syntax.CodeSymbols">
            <summary>
            A list of common symbols that, by convention, have special meaning:
            operators, built-in data types, keywords, trivia, etc.
            </summary>
            <remarks>
            Code that can use symbol forms directly, such as "'!=", tends to be very compact.
            The symbols in this class tend to be abbreviated in order to make usages of this 
            class more compact (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.NotEq"/> is short like its corresponding 
            symbol "'!="). In C# one can access these symbols more easily with 
            <c>using static Loyc.Syntax.CodeSymbols</c> or with
            <c>using S = Loyc.Syntax.CodeSymbols</c> as the Loyc codebase does.
            <para/>
            Some symbols have an alternate name that starts with an underscore. For example,
            <c>_Negate</c> represents the unary minus operator, but in fact it is the same
            symbol as the subtraction operator <c>Sub</c>, <c>'-</c>.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.AltList">
            <summary># is used for lists of things in definition constructs, e.g. 
                <c>#class(Derived, #(Base, IEnumerable), {...})</c>.
            For a time, 'tuple was used for this purpose; the problem is that a
            find-and-replace operation intended to find run-time tuples could 
            accidentally match one of these lists. So I decided to dedicate # 
            for use inside special constructs; its meaning depends on context.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.BadCode">
            <summary>An identifier or call with this Name indicates that parsing or 
            analysis failed earlier and that an error message has already been 
            printed.</summary>
            <remarks>When code in a compiler sees this symbol it should be seen as
            a signal to avoid printing further error messages that involve the same
            node. Typically, a node named #badCode should replace the bad code, and 
            it may have an argument that describes the error, which could be printed 
            at runtime if compilation continues to completion.</remarks>
            <example>#badCode("Argument 2: Cannot convert 'string' to 'int'.")</example>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Internal">
            <summary>Provides general access within a library or program (implies
            #protected_in).</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Public">
            <summary>Provides general access, even outside the assembly (i.e. 
            dynamic-link library). Implies #internal, #protectedIn and #protected.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.ProtectedIn">
            <summary>Provides access to derived classes only within the same library
            or program (i.e. assembly). There is no C# equivalent to this keyword,
            which does not provide access outside the assembly.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Protected">
            <summary>Provides access to all derived classes. Implies #protected_in.
            #protected #internal corresponds to C# "protected internal"</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Private">
            <summary>Revokes access outside the same space and nested spaces. This 
            can be used in spaces in which the default is not private to request
            private as a starting point. Therefore, other flags (e.g. #protected_ex)
            can be added to this flag to indicate what access the user wants to
            provide instead.
            </summary><remarks>
            The name #private may be slightly confusing, since a symbol marked 
            #private is not actually private when there are other access markers
            included at the same time. I considered calling it #revoke instead,
            since its purpose is to revoke the default access modifiers of the
            space, but I was concerned that someone might want to reserve #revoke 
            for some other purpose.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.FilePrivate">
            <summary>Used with #alias to indicate that an alias is local to the
            current source file. <c>[#filePrivate] #alias(X = Y, #())</c> is the long
            form of <c>using X = Y</c> in EC#.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaWordAttribute">
            "%wordAttribute": in EC#, this trivia is placed on an identifier treated as an attribute (e.g. partial, async).
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.RawText">
            #rawText must be a call with a single literal argument. The Value of
            the argument is converted to a string and printed out by EcsNodePrinter 
            without any filtering, e.g. `#rawText("Hello")` is printed `Hello`.
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)">
            <summary>Returns true if the symbol is a pair of square brackets with 
            zero or more commas inside, e.g. "[,]", which in EC# represents an array 
            type of a specific number of dimensions.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.CountArrayDimensions(Loyc.Symbol)">
            <summary>Returns the rank of an array symbol when <see cref="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)"/> 
            is true, or 0 if the symbol does not represent an array type.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.GetArrayKeyword(System.Int32)">
            <summary>Gets the Symbol for an array with the specified number of 
            dimensions, e.g. <c>GetArrayKeyword(3)</c> returns <c>[,,]</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IParsingService">
            <summary>An interface that encapsulates the lexer and parser of a 
            programming language, or a non-programming language that can be 
            represented by Loyc trees.</summary>
            <remarks>
            The simplest way to parse code is with the extension method 
            <c>Parse(string, IMessageSink msgs = null, Symbol inputType = null)</c>.
            The simplest way to print is with <c>Print(LNode, IMessageSink)</c>
            <para/>
            The ToString() method should return a string that indicates the 
            programming language represented by this object, e.g. "Enhanced C#".
            </remarks>
            <seealso cref="T:Loyc.Syntax.ParsingService"/>
            <seealso cref="T:Loyc.Syntax.ILNodePrinter"/>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.FileExtensions">
            <summary>Standard file extensions for this language, without leading 
            dots, with the first one being the most common.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.HasTokenizer">
            <summary>Returns true if the <see cref="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/> method is available.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.CanPreserveComments">
            <summary>Returns true if the parser supports preserving comments.</summary>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Returns a lexer that is configured to begin reading the specified file.</summary>
            <param name="text">Text to be tokenized (e.g. <see cref="T:Loyc.UString"/>)</param>
            <param name="fileName">File name to be associated with any errors that occur.</param>
            <param name="msgs">Error messages are sent to this object.</param>
            <remarks>
            The returned lexer should be a "simple" tokenizer. If the language uses 
            tree lexing (in which tokens are grouped by parentheses and braces),
            the returned lexer should NOT include the grouping process.
            <para/>
            It is recommended that the implementation of this method filter out 
            spaces (for best performance) but not comments or newlines. If there is a 
            preprocessor, it should not run. If <see cref="P:Loyc.Syntax.ParsingOptions.PreserveComments"/>
            is false, it is not this method's responsibility to filter them out.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Parses a source file into one or more Loyc trees.</summary>
            <param name="text">input file or string.</param>
            <param name="fileName">A file name to associate with errors, warnings, and output nodes.</param>
            <param name="msgs">Error and warning messages are sent to this object.
            If this parameter is null, messages should be sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="options">Parsing options.</param>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>If <see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is true, this method accepts a 
            lexer returned by Tokenize() and begins parsing.</summary>
            <param name="input">A source of tokens.</param>
            <param name="msgs">Error and warning messages are sent to this object. 
            If this parameter is null, messages should be sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is false.</exception>
            <remarks>
            This method adds any preprocessing steps to the lexer (tree-ification 
            or token preprocessing) that are required by this language before it 
            sends the results to the parser. If possible, the output is computed 
            lazily.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Parses a token tree, such as one that came from a token literal.</summary>
            <param name="tokens">List of tokens</param>
            <param name="file">A source file to associate with errors, warnings, and output nodes.</param>
            <param name="msgs">Error and warning messages are sent to this object.
            If this parameter is null, messages should be sent to <see cref="P:Loyc.MessageSink.Default"/>.</param>
            <param name="options">Indicates how the input should be parsed. </param>
            <remarks>
            Some languages may offer token literals, which are stored as token trees
            that can be processed by "macros" or compiler plugins. A macro may wish 
            to parse some of the token literal using the host language's parser 
            (e.g. LLLPG needs to do this), so this method is provided for that 
            purpose.
            </remarks>
            <exception cref="T:System.NotSupportedException">This feature is not supported 
            by this parsing service.</exception>
        </member>
        <member name="T:Loyc.Syntax.ParsingService">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.IParsingService"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.Default">
            <summary>Gets or sets the default language service on this thread. If 
            no service has been assigned on this thread, returns <see cref="F:Loyc.Syntax.Les.Les2LanguageService.Value"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.RegisteredLanguages">
            <summary>Dictionary of registered parsing services, keyed by file extension 
            (without leading dots). The default dictionary contains one pair: 
            <c>("les", LesLanguageService.Value)</c></summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Register(Loyc.Syntax.IParsingService,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Registers a parsing service.</summary>
            <param name="service">Service to register.</param>
            <param name="fileExtensions">File extensions affected (null to use the service's own list)</param>
            <returns>The number of new file extensions registered, or 0 if none.</returns>
            <remarks>This method does not replace existing registrations.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Unregister(Loyc.Syntax.IParsingService,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Unregisters a language service.</summary>
            <param name="service">Service to unregister</param>
            <param name="fileExtensions">File extensions affected (null to use the service's own list)</param>
            <returns>The number of file extensions unregistered, or 0 if none.</returns>
            <remarks>The service for a file extension is not removed unless the given service reference is equal to the registered service.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.GetServiceForFileName(System.String)">
            <summary>Finds the language service associated with the longest matching registered file extension.</summary>
            <remarks>Returns null if there is no registered language service for the filename's extension.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)">
            <summary>Sets the current language service, returning a value suitable 
            for use in a C# using statement, which will restore the old service.</summary>
            <param name="newValue">new value of Current</param>
            <example><code>
            LNode code;
            using (var old = ParsingService.PushCurrent(LesLanguageService.Value))
                code = ParsingService.Current.ParseSingle("This `is` LES_code;");
            </code></example>
        </member>
        <member name="T:Loyc.Syntax.ParsingService.PushedCurrent">
            <summary>Returned by <see cref="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Tokenize(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/> using an empty string as the file name.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Tokenize(Loyc.Syntax.IParsingService,Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/> using default options.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/> using an empty string as the file name.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Parses a string by invoking <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/> using an empty string as the file name.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Parses a string and expects exactly one output.</summary>
            <exception cref="T:System.InvalidOperationException">The output list was empty or contained multiple nodes.</exception>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)"/>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseSingle(Loyc.Syntax.IParsingService,Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Syntax.IParsingOptions)">
            <summary>Parses a string and expects exactly one output.</summary>
            <exception cref="T:System.InvalidOperationException">The output list was empty or contained multiple nodes.</exception>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,System.IO.Stream,System.String,Loyc.Syntax.ParsingMode,Loyc.IMessageSink,System.Boolean)">
            <summary>Parses a Stream.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.Tokenize(Loyc.Syntax.IParsingService,System.IO.Stream,System.String,Loyc.IMessageSink)">
            <summary>Parses a Stream.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.ParseFile(Loyc.Syntax.IParsingService,System.String,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)">
            <summary>Opens the specified file, parses the entire file, and closes the file.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.TokenizeFile(Loyc.Syntax.IParsingService,System.String,Loyc.IMessageSink)">
            <summary>Opens the specified file and tokenizes it.</summary>
        </member>
        <member name="T:Loyc.Syntax.IdNode">
            <summary>Base class of all nodes that represent simple identifiers (including special symbols such as #foo).</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralNode">
            <summary>Base class of all nodes that represent literal values such as 123 and "foo".</summary>
        </member>
        <member name="T:Loyc.Syntax.CallNode">
            <summary>Base class of all nodes that represent calls such as <c>f(x)</c>, 
            operator calls such as <c>x + y</c>, braced blocks, and all other things 
            that are not simple symbols and literals.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeScanMode">
            <summary>Specifies which children to enumerate when calling <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.DescendantsFrame">
            <summary>Helper class used to enumerate <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode">
             <summary>All nodes in a Loyc syntax tree share this base class.</summary>
             <remarks>
             Loyc defines only three types of nodes: simple symbols, literals, and calls.
             <ul>
             <li>A <see cref="T:Loyc.Syntax.IdNode"/> is a simple identifier, such as a VariableName</li>
             <li>A <see cref="T:Loyc.Syntax.LiteralNode"/> is a literal constant, such as 123 or "hello"</li>
             <li>A <see cref="T:Loyc.Syntax.CallNode"/> encompasses all other kinds of nodes, such as
             normal function calls like <c>f(x)</c>, generic specifications like <c>f&lt;x></c>
             (represented as <c>@'of(f, x)</c>), braced blocks of statements (represented as
             <c>@`'{}`(stmt1, stmt2, ...)</c>), and so on.</li>
             </ul>
             See http://loyc.net/loyc-trees to learn more about the Loyc tree concept.
             <para/>
             This class provides access to all properties of all three types of nodes,
             in order to make this class easier to access from plain C#, and to avoid
             unnecessary downcasting in some cases. In fact, you never need to use the
             derived classes; you can think of them simply as a way that the implementation
             is optimized.
             <para/>
             Loyc nodes are immutable (except the <see cref="P:Loyc.Syntax.LNode.Style"/> property).
            
             <h3>Important properties</h3>
             
             The main properties of a node are
             <ol>
             <li><see cref="P:Loyc.Syntax.LNode.Attrs"/>: holds the attributes of the node, if any.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Name"/>: the name of an <see cref="T:Loyc.Syntax.IdNode"/>, or the name 
                of the <see cref="T:Loyc.Syntax.IdNode"/> that is acting as the <see cref="P:Loyc.Syntax.LNode.Target"/> 
                of a <see cref="T:Loyc.Syntax.CallNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Value"/>: the value of a <see cref="T:Loyc.Syntax.LiteralNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Target"/>: the target of a <see cref="T:Loyc.Syntax.CallNode"/>. It 
                represents a method, macro, or special identifier that is being called.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Args"/>: holds the arguments to a <see cref="T:Loyc.Syntax.CallNode"/>,
                if any. Returns an empty list if the node does not have an argument list.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Range"/>: indicates the source file that the node came from
                and location in that source file.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Style"/>: an 8-bit flag value that is used as a hint to the
                node printer about how the node should be printed. For example, a hex
                literal like 0x10 has the <see cref="F:Loyc.Syntax.NodeStyle.Alternate"/> style to
                distinguish it from decimal literals such as 16. Custom display styles 
                that do not fit in the Style property can be expressed with attributes.</li>
             </ol>
             To learn more about working with LNode, see http://loyc.net/loyc-trees/dotnet.html
             </remarks>
        </member>
        <member name="F:Loyc.Syntax.LNode.Missing">
            <summary>The empty identifier, used to represent missing information.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.InParensTrivia">
            <summary>Used by the <c>quote {...}</c> macro.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Range">
            <summary>Returns the location and range in source code of this node.</summary>
            <remarks>
            A parser should record a sufficiently wide range for each parent node, 
            such that all children are fully contained within the range. However, 
            this is not an invariant; macros can splice together syntax trees from 
            different source files or add synthetic nodes, so that the parent range
            does not necessarily include all child ranges. (In fact, in general it 
            is impossible to ensure that parent ranges include child ranges because
            a parent can only specify a single source file, while children can come
            from several source files.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Source">
            <summary>Returns the source file (shortcut for <c><see cref="P:Loyc.Syntax.LNode.Range"/>.Source</c>).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Loyc#ILocation#Location">
            <summary>Returns Range.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Style">
            <summary>Indicates the preferred style to use when printing the node to a text string.</summary>
            <remarks>
            The Style is an 8-bit value that acts as a hint to the node printer about 
            how the node should be printed. Custom display styles that do not fit in 
            the Style property can be expressed with special "trivia" attributes that 
            have a <see cref="P:Loyc.Syntax.LNode.Name"/> starting with <c>%</c>. (trivia attributes, which
            are also used to store comments in the syntax tree, are not printed like
            normal attributes and are normally ignored if the node printer does not 
            specifically recognize them.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Attrs">
            <summary>Returns the attribute list for this node.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.IsFrozen">
            <summary>Returns true if the node is immutable, and false if any part of it can be edited.
            Currently, mutable nodes are not implemented.</summary>
            <remarks>Debugger-hidden until such time as mutable nodes actually exist.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Kind">
            <summary>Returns the <see cref="T:Loyc.Syntax.LNodeKind"/>: Symbol, Literal, or Call.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Name">
            <summary>Returns the Symbol if <see cref="P:Loyc.Syntax.LNode.IsId"/>. If this node is 
            a call (<see cref="P:Loyc.Syntax.LNode.IsCall"/>) and <c>Target.IsId</c> is true, 
            this property returns <c>Target.Name</c>. In all other cases, the name
            is <see cref="F:Loyc.GSymbol.Empty"/>. Shall not return null.</summary>
            <remarks>Examples (using C#/LES syntax):
            <pre>
            Expression   Kind    Name (blank if empty)
            hello        Id      hello
            @#if         Id      #if
            Foo(x, y)    Call    Foo
            x += y       Call    +=
            x.Foo(y)     Call    
            5.0          Literal 
            </pre>
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.HasSpecialName">
            <summary>Returns true if <see cref="P:Loyc.Syntax.LNode.Name"/> is a "special" name 
            (i.e. starts with '#' or '\'' or '.' or any character below 48 in ASCII).</summary>
            <remarks>Note that this property returns false for the empty identifier <c>@``</c>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.IsSpecialName(System.String)">
            <summary>Returns true if <c>name</c> is considered a "special" name that
            starts with any character below 48 in ASCII, such as '#', '\'', and '.'.</summary>
            <remarks>
            This returns false for the empty string or null. 
            <para/>
            In order to keep the check trivially simple, this returns true for '$'
            even though it is <i>not</i> special in some languages (e.g. JavaScript).
            <para/>
            Letters, underscores, digits, and some punctuation do not count as special.
            The full list of specials is <c>! " # $ % &amp; ' ( ) * + , - . /</c> plus
            the space character and the control characters.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithName(Loyc.Symbol)">
            <summary>Creates a node with a new value for Name.</summary>
            <remarks>If IsId, the Name is simply changed. If <see cref="P:Loyc.Syntax.LNode.IsCall"/>, 
            this method returns the equivalent of <c>WithTarget(Target.WithName(name))</c>
            (which may be optimized for the particular call type). If <see 
            cref="P:Loyc.Syntax.LNode.IsLiteral"/>, the <see cref="P:Loyc.Syntax.LNode.Kind"/> changes to <see cref="F:Loyc.Syntax.LNodeKind.Id"/> in
            order to set the name.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Value">
            <summary>Returns the value of a literal node, or <see cref="F:Loyc.NoValue.Value"/> 
            if this node is not a literal (<see cref="P:Loyc.Syntax.LNode.IsLiteral"/> is false).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.TextValue">
            <summary>If this node <see cref="P:Loyc.Syntax.LNode.IsLiteral"/>, gets the original text of 
            the literal, if it is available. This property is empty if the node was 
            created programmatically from a value, or if the parser did not save the 
            original text, or if this is not a literal.</summary>
            <remarks>If you need a string version of the value, call ToString() on it.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.TypeMarker">
            <summary>If this node <see cref="P:Loyc.Syntax.LNode.IsLiteral"/>, gets the type marker 
            associated with the literal. This property is null if the node was 
            created programmatically from a value, or if the parser did not save the 
            type marker, or if this is not a literal.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithValue(System.Object)">
            <summary>Creates a new literal node with a different Value than the current literal node.</summary>
            <exception cref="T:System.InvalidOperationException">The node was not a literal already.</exception>
        </member>
        <member name="P:Loyc.Syntax.LNode.Target">
            <summary>Returns the target of a method call, or null if <see cref="P:Loyc.Syntax.LNode.IsCall"/> 
            is false. The target can be a symbol with no name (<see cref="F:Loyc.GSymbol.Empty"/>)
            to represent a parenthesized expression, if there is one argument.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Args">
            <summary>Returns the argument list of this node. Always empty when <c><see cref="P:Loyc.Syntax.LNode.IsCall"/>==false</c>.</summary>
            <remarks>
            Depending on the <see cref="P:Loyc.Syntax.LNode.Target"/>, Args may represent an actual 
            argument list, or it may represent some other kind of list. For 
            example, if the target is "{}" then Args represents a list of 
            statements in a braced block, and if the target is ">=" then Args 
            represents the two arguments to the ">=" operator.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithArgs(Loyc.Syntax.LNodeList)">
            <summary>Creates a Node with a new argument list. If this node is not a 
            call, a new node is created using this node as its target. Otherwise,
            the existing argument list is replaced.</summary>
            <param name="args">New argument list</param>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Syntax.LNode,Loyc.Syntax.LNodeList)">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Symbol,Loyc.Syntax.LNodeList)">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.Clone">
            <summary>Creates a copy of the node. Since nodes are immutable, there 
            is little reason for an end-user to call this, but Clone() is used 
            internally as a helper method by the WithXyz() methods.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Printer">
            <summary>Gets or sets the default node printer on the current thread,
            which controls how nodes are serialized to text by default.</summary>
            <remarks>The LES printer is the default, and will be used if you try
            to set this property to null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.ILNodePrinter)">
            <summary>Helps you change printers temporarily. Usage in C#: 
            <c>using (LNode.PushPrinter(myPrinter)) { ... }</c></summary>
            <remarks>For example, to switch to the EC# printer, use
            <c>using (LNode.PushPrinter(EcsNodePrinter.Printer)) { ... }</c>.
            This changes the default printer. If you don't want to change the
            default printer, please invoke the printer directly: 
            <code>
                var sb = new StringBuilder();
                EcsNodePrinter.Printer(node, sb, MessageSink.Trace);
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode.PushedPrinter">
            <summary>Returned by <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.ILNodePrinter)"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.TriviaValue">
            <summary>Gets the value of <c>Args[0].Value</c>, if Args[0] exists; 
            otherwise, returns <see cref="F:Loyc.NoValue.Value"/>.</summary>
            <remarks>"Trivia nodes" are used to efficiently represent the value of
            trivia and non-tree <see cref="T:Loyc.Syntax.Lexing.Token"/>s; they can be created by 
            calling the <see cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/> function. Since an LNode is not 
            allowed to have both a Name and a Value (as there is no syntax in LES 
            or EC# for such a node), a trivia node pretends that there is an 
            argument list with one item, and that one item is always a literal 
            whose Value is the value stored in the trivia node. Thus, a token node 
            is printed out as <c>TokenType(Value)</c> where <c>Value</c> is some 
            literal.
            <para/>
            If you suspect you're dealing with a trivia node, it is wasteful to 
            actually call <c>node.Args[0].Value</c> since this causes a temporary
            token list to be allocated. Instead you should use this property, which
            returns the token value without allocating memory. Of course, if this 
            property is called on a non-trivia node, it simply returns 
            <c>Args[0].Value</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList,Loyc.Syntax.LNode.CompareMode)">
            <summary>Compares two lists of nodes for structural equality.</summary>
            <param name="mode">Whether to pay attention to <see cref="P:Loyc.Syntax.LNode.Style"/> and trivia attributes</param>
            <remarks>Position information is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)">
            <inheritdoc cref="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)"/>
        </member>
        <member name="T:Loyc.Syntax.LNode.CompareMode">
            <summary>Used with <see cref="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.CompareMode.Normal">
            <summary>This is the default value. In this mode, the <see cref="P:Loyc.Syntax.LNode.Style"/> 
            of each node is ignored, the trivia attributes are significant, and the 
            <see cref="P:Loyc.Syntax.LNode.TypeMarker"/>s of a literal are compared only if the type of each
            <see cref="P:Loyc.Syntax.LNode.Value"/> is string or <see cref="T:Loyc.UString"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.CompareMode.Styles">
            <summary>When this flag is used, two nodes are not equal if their 
            <see cref="P:Loyc.Syntax.LNode.Style"/>s are different.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.CompareMode.IgnoreTrivia">
            <summary>When this flag is used, trivia attributes are ignored so that 
            two nodes can be "equal" even if they have different trivia.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.CompareMode.TypeMarkers">
            <summary>When this flag is used, two literals are never equal if their 
            <see cref="P:Loyc.Syntax.LNode.TypeMarker"/>s are unequal.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.ILNode,Loyc.Syntax.LNode.CompareMode)">
            <summary>Compares two nodes for structural equality. Two nodes are 
            considered equal if they have the same kind, the same name, the same 
            value, the same arguments, and the same attributes.</summary>
            <param name="mode">Whether to pay attention to <see cref="P:Loyc.Syntax.LNode.Style"/> and trivia attributes</param>
            <remarks>Position information (<see cref="P:Loyc.Syntax.LNode.Range"/>) is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.GetHashCode">
            <summary>Gets the hash code based on the structure of the tree.</summary>
            <remarks>
            If the tree is large, less than the entire tree is scanned to produce 
            the hashcode (in the absolute worst case, about 4000 nodes are examined, 
            but usually it is less than 100).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.CallsMin(Loyc.Symbol,System.Int32)">
            <summary>Returns true if this is a call with the specified name and the specified minimum number of arguments.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.CallsMin(System.String,System.Int32)">
            <summary>Returns true if this is a call with the specified name and the specified minimum number of arguments.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHead">
            <summary>Returns true if this is not a call, or if the call's Target is an Id or a Literal.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHeadWithoutPAttrs">
            <summary>Returns true if this is not a call, or if the call's Target is an Id or a Literal, and the Target has only trivia attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeLists(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Some <see cref="T:Loyc.Syntax.CallNode"/>s are used to represent lists. This 
            method merges two nodes, forming or appending a list (see remarks).</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="listName">The <see cref="P:Loyc.Syntax.LNode.Name"/> used to detect whether a 
            node is a list (typically "#splice"). Any other name is considered a 
            normal call, not a list. If this method creates a list from two non-
            lists, this parameter specifies the Name that the list will have.</param>
            <returns>The merged list.</returns>
            <remarks>
            The order of the data is retained (i.e. the data in node1 is inserted
            before the data in node2).
            <ul>
            <li>If either node1 or node2 is null, this method returns the other (node1 ?? node2).</li>
            <li>If both node1 and node2 are lists, this method merges the list 
            into a single list by appending node2's arguments at the end of node1.
            The attributes of node1 are kept and those of node2 are discarded.</li>
            <li>If one of the nodes is a list and the other is not, the non-list
            is inserted into the list's Args.</li>
            <li>If neither node is a list, a list is created with both nodes as 
            its two Args.</li>
            </ul>
            </remarks>
            <seealso cref="M:Loyc.Syntax.LNodeExt.WithSpliced(Loyc.Syntax.LNodeList,System.Int32,Loyc.Syntax.LNode,Loyc.Symbol)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeBinary(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Combines two nodes using a binary operator or function.</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="binaryOpName">Binary operator to use when the nodes are not null.</param>
            <returns>If either node1 or node2 is null, this method returns the other node
            (node1 ?? node2), otherwise the nodes are joined with the specified operator.</returns>
            <seealso cref="M:Loyc.Syntax.LNode.FlattenBinaryOpSeq(Loyc.Syntax.LNode,Loyc.Symbol,System.Nullable{System.Boolean})"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.FlattenBinaryOpSeq(Loyc.Syntax.LNode,Loyc.Symbol,System.Nullable{System.Boolean})">
            <summary>Converts a sequence of the same operator (e.g. `x+y+z`) to a list (e.g. x, y, z).</summary>
            <param name="expr">An expression that may or may not call the operator.</param>
            <param name="opName">The operator to recognize.</param>
            <param name="rightAssociative">Whether the operator is right associative. 
            If this is null then either or both associativities will work (e.g. 
            <c>(a*b)*(c*d)</c> is flattened to a,b,c,d).</param>
            <returns>A list of subexpressions with the operator removed. If <c>expr</c> 
            does not call the specified binary operator, the list contains a single item 
            which is the original expression.</returns>
            <remarks>This is the reverse operation of <see cref="M:Loyc.Syntax.LNode.MergeBinary(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)">
            <summary>Transforms the <see cref="P:Loyc.Syntax.LNode.Target"/>, parameters, and optionally
            the attributes of an LNode, returning another LNode of the same Kind. If 
            the selector makes no changes, Select() returns <c>this</c>.</summary>
            <remarks>The selector is not allowed to return null, but it can return
            <c>NoValue.Value</c> to delete a parameter or target. If the current 
            node is a target, it cannot be deleted, so it is replaced with 
            <c>#splice()</c> which, by convention, represents an empty list.
            If you're wondering why we don't use <c>null</c> for deletions, it is 
            because the functionality of this method is actually implemented by 
            <see cref="M:Loyc.Collections.VList`1.WhereSelect(System.Func{`0,Loyc.Maybe{`0}})"/>; since T could be a 
            value type, that method cannot use null as a signal to delete items from 
            the collection.
            <para/>
            It is not possible to delete the <see cref="P:Loyc.Syntax.LNode.Target"/> of a call, and
            if the selector returns <c>NoValue.Value</c> for the Target, the target 
            is replaced with an empty call to <c>#splice()</c>.</remarks>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.ReplaceRoot">
            <summary>When calling <c>n.ReplaceRecursive</c>, specifies that the 
            selector should be called on <c>n</c> itself, not just its children.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.ProcessAttrs">
            <summary>When calling <see cref="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)"/>
            or <see cref="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)"/>, specifies
            that attributes should be processed rather than left unchanged.</summary>
        </member>
        <member name="F:Loyc.Syntax.LNode.ReplaceOpt.Default">
            <summary>ReplaceRoot and ProcessAttrs</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Maybe{Loyc.Syntax.LNode}},Loyc.Syntax.LNode.ReplaceOpt)">
            <summary>Performs a recursive find-and-replace operation, by attempting
            to replace each child (among <see cref="P:Loyc.Syntax.LNode.Attrs"/>, <see cref="P:Loyc.Syntax.LNode.Target"/>, 
            <see cref="P:Loyc.Syntax.LNode.Args"/>) using the specified selector. This method can also
            be used for simple searching, by giving a selector that always returns 
            null.</summary>
            <param name="matcher">This method is called for each descendant, and
            optionally the root node. If the selector returns a node, the new node 
            replaces the node that was passed to <c>selector</c> and the children of 
            the new node are ignored. If the selector returns null, children of the 
            child are scanned recursively. If the selector returns Maybe{LNode}.NoValue
            then the current node is deleted if it is an argument or attribute. If 
            the current node is a target, it cannot be deleted, so it is replaced 
            with <c>#splice()</c> which, by convention, represents an empty list.
            If you delete the root node then this method returns Maybe{LNode}.NoValue.</param>
            <param name="options">Options, see <see cref="T:Loyc.Syntax.LNode.ReplaceOpt"/>.</param>
            <returns>The new node produced after all replacements have occurred.</returns>
            <remarks>If <c>replaceFunc</c> always returns null (or if <c>replaceRoot</c>
            is false and the root has no children), <c>ReplaceRecursive</c> returns 
            <c>this</c>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetTrailingTrivia(Loyc.Syntax.LNode)">
            <summary>Gets all trailing trivia attached to the specified node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetTrailingTrivia(Loyc.Syntax.LNodeList)">
            <summary>Gets all trailing trivia attached to the specified node.</summary>
            <remarks>Trailing trivia is represented by a call to <c>%trailing</c> in
            a node's attribute list; each argument to %trailing represents one
            piece of trivia. If the attribute list has multiple calls to 
            %trailing, this method combines those lists into a single list.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithTrailingTrivia(Loyc.Syntax.LNode,Loyc.Syntax.LNodeList)">
            <summary>Removes a node's trailing trivia and adds a new list of trailing trivia.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithTrailingTrivia(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)">
            <summary>Removes all existing trailing trivia from an attribute list and adds a new list of trailing trivia.</summary>
            <remarks>This method has a side-effect of recreating the %trailing
            node, if there is one, at the end of the attribute list. If <c>trivia</c>
            is empty then all calls to %trailing are removed.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutTrailingTrivia(Loyc.Syntax.LNodeList)">
            <summary>Gets a new list with any %trailing attributes removed.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutTrailingTrivia(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList@)">
            <summary>Gets a new list with any %trailing attributes removed. Trailing 
            trivia inside those attributes are returned in an `out` parameter.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNode,Loyc.Syntax.LNodeList)">
            <summary>Adds additional trailing trivia to a node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNode,Loyc.Syntax.LNode)">
            <summary>Adds additional trailing trivia to a node.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)">
            <summary>Adds additional trailing trivia to an attribute list. Has no effect if <c>trivia</c> is empty.</summary>
            <remarks>
            Trailing trivia is represented by a call to <c>%trailing</c> in a node's 
            attribute list; each argument to %trailing represents one piece of trivia.
            <para/>
            In the current design, this method has a side-effect of recreating the %trailing
            node at the end of the attribute list, and if there are multiple %trailing
            lists, consolidating them into a single list, but only if the specified <c>trivia</c> 
            list is not empty.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.PlusTrailingTrivia(Loyc.Syntax.LNodeList,Loyc.Syntax.LNode)">
            <summary>Adds additional trailing trivia to an attribute list.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Interprets a node as a list by returning <c>block.Args</c> if 
            <c>block.Calls(listIdentifier)</c>, otherwise returning a one-item list 
            of nodes with <c>block</c> as the only item.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.Unsplice(Loyc.Syntax.LNode)">
            <summary>Converts an expression to a list. Similar to calling 
            <c>AsList(block, CodeSymbols.Splice)</c>, if the expression calls #splice
            then the arguments of the splice are returned, and if not then the 
            argument is converted to a list with one item. However, if the call to 
            #splice has attached trivia/attributes, those attributes are attached to
            the output list using <see cref="M:Loyc.Syntax.LNodeExt.IncludingAttributes(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)"/>.
            </summary>
            <param name="node">A node that may or may not be a call to #splice</param>
            <returns>A list of nodes that <c>block</c> is equivalent to.</returns>
            <remarks>
            Attributes attached to #splice are ordinarily attached to the first item 
            in the output list, but any %trailing attribute is attached to the last
            item instead. If the #splice() call has no arguments, then (i) if it has
            no trivia attributes, an empty list is returned, but (ii) if it has 
            trivia attributes, the attributes themselves are returned as the content
            of the list. This assumes that printers can print 
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.IncludingTriviaFrom(Loyc.Syntax.LNode,Loyc.Syntax.LNode)">
            <summary>Finds trivia attributes attached directly to <c>otherNode</c>, and 
            returns a new version of <c>node</c> with these attributes added.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.IncludingAttributes(Loyc.Syntax.LNodeList,Loyc.Syntax.LNodeList)">
            <summary>Prepends attributes to the first item in a list, except for
            trailing trivia (%trailing(...)), which is appended to the last item in 
            the list. If the list is empty, the attributes are ignored.</summary>
            <returns>A modified version of the list with attributes added. If the
            attribute list is empty, the empty <c>list</c> is returned unchanged.
            </returns>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsLNode(Loyc.Syntax.LNodeList,Loyc.Symbol)">
            <summary>Converts a list of LNodes to a single LNode by using the list 
            as the argument list in a call to the specified identifier, or, if the 
            list contains a single item, by returning that single item.</summary>
            <param name="listIdentifier">Target of the node that is created if <c>list</c>
            does not contain exactly one item. Typical values include "'{}" and "#splice".</param>
            <remarks>This is the reverse of the operation performed by <see cref="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode,Loyc.Syntax.SourceRange)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
            <remarks>The node's range is changed to the provided <see cref="T:Loyc.Syntax.SourceRange"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.InParens(Loyc.Syntax.LNode,Loyc.Syntax.ISourceFile,System.Int32,System.Int32)">
            <summary>Returns the same node with a parentheses attribute added.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.WithoutOuterParens(Loyc.Syntax.LNode)">
            <summary>Removes a single pair of parentheses, if the node has a 
            %inParens attribute. Returns the same node when no parens are 
            present.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.MatchesPattern(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Collections.MMap{Loyc.Symbol,Loyc.Syntax.LNode}@,Loyc.Syntax.LNodeList@)">
            <summary>Determines whether one Loyc tree "matches" another. This is 
            different from a simple equality test in that (1) trivia atributes do 
            not have to match, and (2) the pattern can contain placeholders represented
            by calls to $ (the substitution operator) with an identifier as a parameter.
            Placeholders match any subtree, and are saved to the <c>captures</c> map.
            </summary>
            <param name="candidate">A node that you want to compare with a 'pattern'.</param>
            <param name="pattern">A syntax tree that may contain placeholders. A 
            placeholder is a call to the $ operator with one parameter, which must 
            be either (A) a simple identifier, or (B) the ".." operator with a simple
            identifier as its single parameter. Otherwise, the $ operator is treated 
            literally as something that must exist in <c>candidate</c>). The subtree 
            in <c>candidate</c> corresponding to the placeholder is saved in 
            <c>captures</c>.</param>
            <param name="captures">A table that maps placeholder names from 
            <c>pattern</c> to subtrees in <c>candidate</c>. You can set your map to 
            null and a map will be created for you if necessary. If you already have
            a map, you should clear it before calling this method.</param>
            <param name="unmatchedAttrs">On return, a list of trivia attributes in 
            <c>candidate</c> that were not present in <c>pattern</c>.</param>
            <returns>true if <c>pattern</c> matches <c>candidate</c>, false otherwise.</returns>
            <remarks>
            Attributes in patterns are not yet supported.
            <para/>
            This method supports multi-part captures, which are matched to 
            placeholders whose identifier either (A) has a #params attribute or
            (B) has the unary ".." operator applied to it (for example, if 
            the placeholder is called p, this is written as <c>$(params p)</c> in 
            EC#.) A placeholder that looks like this can match multiple arguments or
            multiple statements in the <c>candidate</c> (or <i>no</i> arguments, or
            no statements), and will become a #splice(...) node in <c>captures</c>
            if it matches multiple items. Multi-part captures are often useful for
            getting lists of statements before and after some required element,
            e.g. <c>{ $(params before); MatchThis($something); $(params after); }</c>
            <para/>
            If the same placeholder appears twice then the two matching items are 
            combined into a single output node (calling #splice).
            <para/>
            If matching is unsuccessful, <c>captures</c> and <c>unmatchedAttrs</c>
            may contain irrelevant information gathered during the attempt to match.
            <para/>
            In EC#, the quote(...) macro can be used to create the LNode object for 
            a pattern.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.GetCaptureIdentifier(Loyc.Syntax.LNode,System.Boolean)">
            <summary>Checks if <c>pattern</c> matches one of the syntax trees 
            <c>$x</c> or <c>$(..x)</c> or <c>$(...x)</c> for some identifier <c>x</c>.
            These are conventionally used to represent partial syntax trees.</summary>
            <returns>The matched identifier (<c>x</c> in the examples above), or null 
            if <c>pattern</c> was not a match.</returns>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.ToLNode(Loyc.Syntax.ILNode)">
            <summary>Converts <see cref="T:Loyc.Syntax.ILNode"/> to <see cref="T:Loyc.Syntax.LNode"/> recursively.</summary>
        </member>
        <member name="T:Loyc.Syntax.LNodeFactory">
            <summary>Contains helper methods for creating <see cref="T:Loyc.Syntax.LNode"/>s.
            An LNodeFactory holds a reference to the current source file (<see cref="P:Loyc.Syntax.LNodeFactory.File"/>) 
            so that it does not need to be repeated every time you create a node.
            </summary>
        </member>
        <member name="P:Loyc.Syntax.LNodeFactory.ErrorSink">
            <summary>Where errors should be sent if there is an error parsing a literal.</summary>
            <remarks>Attempting to set this to null makes the getter return <see cref="P:Loyc.MessageSink.Default"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.OnNewLine(Loyc.Syntax.LNode)">
            <summary>Adds a leading newline to the node if the first attribute isn't a newline.</summary>
            <remarks>By convention, in Loyc languages, top-level nodes and nodes within 
            braces have an implicit newline, such that a leading blank line appears
            if you add <see cref="F:Loyc.Syntax.CodeSymbols.TriviaNewline"/>. For all other nodes,
            this method just ensures there is a line break.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Literal(Loyc.Syntax.Lexing.Token)">
            <summary>Creates a literal from a <see cref="T:Loyc.Syntax.Lexing.Token"/>. If the token is 
            uninterpreted (<see cref="P:Loyc.Syntax.Lexing.Token.IsUninterpretedLiteral"/>), this method uses 
            <see cref="P:Loyc.Syntax.StandardLiteralHandlers.Value"/> to parse the literal's value;
            otherwise <see cref="M:Loyc.Syntax.LNodeFactory.LiteralFromValueOf(Loyc.Syntax.Lexing.Token)"/> is called to create the 
            literal based on the <see cref="P:Loyc.Syntax.Lexing.Token.Value"/>.</summary>
            <param name="t">Token to be converted</param>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Literal(Loyc.Syntax.Lexing.Token,Loyc.Syntax.ILiteralParser)">
            <summary>Creates a literal from a <see cref="T:Loyc.Syntax.Lexing.Token"/>. If it's an "ordinary"
            token, this function simply calls <see cref="M:Loyc.Syntax.LNodeFactory.LiteralFromValueOf(Loyc.Syntax.Lexing.Token)"/>.
            If it is an "uninterpreted literal" (type marker with text), this function 
            uses the parser provided to interpret the literal, or, if <c>parser</c> is null, 
            calls <see cref="M:Loyc.Syntax.LNodeFactory.UninterpretedLiteral(Loyc.Syntax.Lexing.Token)"/> to create the node without 
            parsing it.</summary>
            <param name="t">Token to be converted</param>
            <param name="parser">Used to obtain a value from an uninterpreted literal,
            which becomes the <see cref="P:Loyc.Syntax.LNode.Value"/> property.</param>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.LiteralFromValueOf(Loyc.Syntax.Lexing.Token)">
            <summary>Creates a literal whose <see cref="P:Loyc.Syntax.LNode.Value"/> is the same as the value of <c>t</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.UninterpretedLiteral(Loyc.Syntax.Lexing.Token)">
            <summary>This method produces a literal by assuming that the provided token 
            is an uninterpreted literal (see <see cref="P:Loyc.Syntax.Lexing.Token.IsUninterpretedLiteral"/>)
            in the current file and that it does not need to be parsed. Therefore, 
            <c>t.Value</c> becomes the <see cref="P:Loyc.Syntax.LNode.TypeMarker"/>, 
            <c>t.TextValue(_file.Text)</c> becomes the <see cref="P:Loyc.Syntax.LNode.TextValue"/>, 
            and the <see cref="P:Loyc.Syntax.LNode.Value"/> will be a boxed copy of TextValue.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(System.String,System.Object)">
            <summary>Creates a trivia node named <c>"%" + suffix</c> with the 
            specified Value attached.</summary>
            <remarks>This method only adds the prefix <c>%</c> if it is not 
            already present in the 'suffix' argument.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(Loyc.Symbol,System.Object,System.Int32,System.Int32)">
            <summary>Creates a trivia node with the specified Value attached.</summary>
            <seealso cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/>
        </member>
        <member name="T:Loyc.Syntax.LNodeVisitor">
            <summary>Base class for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNodeVisitor">
            <summary>Interface for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.
            If your visitor does not need a base class, use <see cref="T:Loyc.Syntax.LNodeVisitor"/> as the base class.</summary>
        </member>
        <member name="T:Loyc.Syntax.StdTriviaNode">
            <summary>A simple call node with a single literal argument. </summary>
            <remarks>
            Essentially, this is a special kind of node with both a name and a value.
            Since there is no syntax (or <see cref="T:Loyc.Syntax.LNodeKind"/>) for a node that has
            both a Name and a Value, the node pretends that it is has a single argument,
            Args[0], which allows this node to be printed as if it were a normal call
            node. For example, if this node has Name=(Symbol)"PI" and Value=3.1415,
            it will be printed as <c>PI(3.1415)</c>. The <see cref="P:Loyc.Syntax.StdTriviaNode.TriviaValue"/>
            property returns this value (in this case, (object)3.1415). Please note
            that the normal <see cref="P:Loyc.Syntax.LNode.Value"/> is still <see cref="F:Loyc.NoValue.Value"/>
            so that if the node is printed and reparsed, it doesn't behave differently.
            <para/>
            This node type is used to represent tokens and trivia nodes with values.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.OperatorShape">
            <summary>An enum of common operator formats.</summary>
            <remarks>It is intentional that the absolute value of each OperatorShape
            (except Other) is the arity of (number of arguments to) that shape.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParseHelpers">
            <summary>Static methods that help with common parsing jobs, such as 
            parsing integers, floats, and strings with C escape sequences.</summary>
            <seealso cref="T:Loyc.Syntax.PrintHelpers"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseHex(Loyc.UString,System.Int32@)">
            <summary>A simple method to parse a sequence of hex digits, without
            overflow checks or other features supported by methods like 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>.</summary>
            <returns><c>true</c> iff the entire string was consumed and the string was nonempty.</returns>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseHex(Loyc.UString@,System.Int32@)">
            <summary>A simple method to parse a sequence of hex digits, without
            overflow checks or other features supported by methods like 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>.</summary>
            <returns>The number of digits parsed</returns>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.HexDigitValue(System.Char)">
            <summary>Gets the integer value for the specified hex digit, or -1 if 
            the character is not a hex digit.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.Base36DigitValue(System.Char)">
            <summary>Gets the integer value for the specified digit, where 'A' maps 
            to 10 and 'Z' maps to 35, or -1 if the character is not a digit or
            letter.</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeCStyle(Loyc.UString,System.Boolean)">
            <summary>Unescapes a string that uses C-style escape sequences, e.g. 
            "\\\n\\\r" becomes "\n\r".</summary>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeCStyle(Loyc.UString,Loyc.Syntax.EscapeC@,System.Boolean)">
            <summary>Unescapes a string that uses C-style escape sequences, e.g. 
            "\\\n\\\r" becomes "\n\r".</summary>
            <param name="encountered">Returns information about whether escape 
            sequences were encountered, and which categories.</param>
            <param name="removeUnnecessaryBackslashes">Causes the backslash before 
            an unrecognized escape sequence to be removed, e.g. "\z" => "z".</param>
            <remarks>See <see cref="M:Loyc.Syntax.ParseHelpers.UnescapeChar(Loyc.UString@,Loyc.Syntax.EscapeC@)"/> for details.</remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.UnescapeChar(Loyc.UString@,Loyc.Syntax.EscapeC@)">
            <summary>Unescapes a single character of a string. Returns the 
            first character if it is not a backslash, or <c>\</c> if it is a 
            backslash but no escape sequence could be discerned.</summary>
            <param name="s">Slice of a string to be unescaped. When using a
            <c>ref UString</c> overload of this method, <c>s</c> will be shorter upon
            returning from this method, as the parsed character(s) are clipped 
            from the beginning (<c>s.InternalStart</c> is incremented by one 
            normally and more than one in case of an escape sequence.)</param>
            <param name="encountered">Bits of this parameter are set according
            to which escape sequence is encountered, if any.</param>
            <remarks>
            This function also decodes (non-escaped) surrogate pairs.
            <para/>
            Code points with 5 or 6 digits such as \u1F4A9 are supported.
            \x escapes must be two digits and set the EscapeC.BackslashX flag.
            \u escapes must be 4 to 6 digits. If a \u escape has more than 4 
            digits, the EscapeC.HasLongEscapes flag is set. Invalid 6-digit 
            escapes like \u123456 are "made valid" by being treated as 5 digits
            (the largest valid escape is <c>\u10FFFF</c>.)
            <para/>
            Supported escapes: <c>\u \x \\ \n \r \0 \' \" \` \t \a \b \f \v</c>
            </remarks>
            <example>
            EscapeC e = 0; 
            UString str = @"\nfoo";
            char c = UnescapeChar(ref str, ref e);
            Contract.Assert(str == "foo");
            Contract.Assert(e == EscapeC.HasEscapes);
            </example>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)">
            <summary>Tries to parse a string to an integer. Unlike <see cref="M:System.Int32.TryParse(System.String,System.Int32@)"/>,
            this method allows parsing to start at any point in the string, it 
            allows non-numeric data after the number, and it can parse numbers that
            are not in base 10.</summary>
            <param name="radix">Number base, e.g. 10 for decimal and 2 for binary.
            Must be in the range 2 to 36.</param>
            <param name="index">Location at which to start parsing</param>
            <param name="flags"><see cref="T:Loyc.Syntax.ParseNumberFlag"/>s that affect parsing behavior.</param>
            <param name="skipSpaces">Whether to skip spaces before parsing. Only 
            the ' ' and '\t' characters are treated as spaces. No space is allowed 
            between '-' and the digits of a negative number, even with this flag.</param>
            <returns>True if a number was found starting at the specified index
            and it was successfully converted to a number, or false if not.</returns>
            <remarks>
            This method never throws. If parsing fails, index is left unchanged, 
            except that spaces are still skipped if you set the skipSpaces flag. 
            If base>36, parsing can succeed but digits above 35 (Z) cannot occur 
            in the output number. If the input number cannot fit in 'result', the 
            return value is false but index increases anyway, and 'result' is a 
            bitwise truncated version of the number.
            <para/>
            When parsing input such as "12.34", the parser stops and returns true
            at the dot (with a result of 12 in this case).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(Loyc.UString@,System.Int32@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseInt(Loyc.UString@,System.Int64@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseInt(System.String,System.Int32@,System.Int32@,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Tries to parse a string to an unsigned integer.</summary>
            <param name="s">A slice of a string to be parsed.</param>
            <param name="radix">Number base, e.g. 10 for decimal and 2 for binary.
            Normally in the range 2 to 36.</param>
            <param name="flags"><see cref="T:Loyc.Syntax.ParseNumberFlag"/>s that affect parsing behavior.</param>
            <returns>True if a number was found starting at the specified index
            and it was successfully converted to a number, or false if not.</returns>
            <remarks>
            This method never throws. It shrinks the slice <c>s</c> as it parses,
            so if parsing fails, <c>s[0]</c> will be the character at which parsing 
            fails. If base>36, parsing can succeed but digits above 35 (Z) cannot 
            be represented in the input string. If the number cannot fit in 
            <c>result</c>, the return value is false and the method's exact behavior
            depends on whether you used <see cref="F:Loyc.Syntax.ParseNumberFlag.StopBeforeOverflow"/>.
            <para/>
            When parsing input such as "12.34", the parser stops and returns true
            at the dot (with a result of 12 in this case).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.Numerics.BigInteger@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <inheritdoc cref="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)"/>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloatParts(Loyc.UString@,System.Int32,System.Boolean@,System.UInt64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,Loyc.Syntax.ParseNumberFlag)">
            <summary>Low-level method that identifies the parts of a float literal
            of arbitrary base (typically base 2, 10, or 16) with no prefix or 
            suffix, such as <c>2.Cp0</c> (which means 2.75 in base 16).</summary>
            <param name="radix">Base of the number to parse; must be between 2
            and 36.</param>
            <param name="mantissa">Integer magnitude of the number.</param>
            <param name="exponentBase2">Base-2 exponent to apply, as specified by
            the 'p' suffix, or 0 if there is no 'p' suffix..</param>
            <param name="exponentBase10">Base-10 exponent to apply, as specified by
            the 'e' suffix, or 0 if there is no 'e' suffix..</param>
            <param name="exponentBaseR">Base-radix exponent to apply. This number
            is based on the front part of the number only (not including the 'p' or
            'e' suffix). Negative values represent digits after the decimal point,
            while positive numbers represent 64-bit overflow. For example, if the
            input is <c>12.3456</c> with <c>radix=10</c>, the output will be 
            <c>mantissa=123456</c> and <c>exponentBaseR=-4</c>. If the input is 
            <c>0123_4567_89AB_CDEF_1234.5678</c> with <c>radix=16</c>, the mantissa 
            overflows, and the result is <c>mantissa = 0x1234_5678_9ABC_DEF1</c> 
            with <c>exponentBaseR=3</c>.</param>
            <param name="numDigits">Set to the number of digits in the number, not 
            including the exponent part.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
            <remarks>
            The syntax required is
            <code>
              ( '+'|'-' )?
              ( Digits ('.' Digits?)? | '.' Digits )
              ( ('p'|'P') ('-'|'+')? DecimalDigits+ )?
              ( ('e'|'E') ('-'|'+')? DecimalDigits+ )?
            </code>
            where Digits refers to one or more digits in the requested base, 
            possibly including underscores or spaces if the flags allow it; similarly, 
            DecimalDigits refers to base-10 digits and is also affected by the
            flags.
            <para/>
            Returns false if there was an error interpreting the input.
            <para/>
            To keep the parser relatively simple, it does not roll back in case of 
            error the way the int parser does. For example, given the input "23p", 
            the 'p' is consumed and causes the method to return false, even though
            the parse could have been successful if it had ignored the 'p'.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloatParts(Loyc.UString@,System.Int32,System.Boolean@,System.UInt64@,System.Int32@,System.Int32@,System.Int32@,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses the parts of a floating-point string. See the other 
            overload for details.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="negative">true if the string began with '-'.</param>
            <param name="mantissa">Integer magnitude of the number.</param>
            <param name="exponentBase2">Base-2 exponent to apply.</param>
            <param name="exponentBase10">Base-10 exponent to apply.</param>
            <param name="numDigits">Set to the number of digits in the number, not including the exponent part.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
            <remarks>
            This method is a wrapper around the other overload that combines 
            the 'exponentBaseR' parameter with 'exponentBase2' or 'exponentBase10'
            depending on the radix. For example, when radix=10, this method 
            adds <c>exponentBaseR</c> to <c>exponentBase10</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseDouble(Loyc.UString@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses a string to a double-precision float, returning NaN on 
            failure or an infinity value on overflow.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.TryParseFloat(Loyc.UString@,System.Int32,Loyc.Syntax.ParseNumberFlag)">
            <summary>Parses a string to a single-precision float, returning NaN on 
            failure or an infinity value on overflow.</summary>
            <param name="radix">Base of the number to parse; must be 2 (binary), 
            4, 8 (octal), 10 (decimal), 16 (hexadecimal) or 32.</param>
            <param name="flags">Alters parsing behavior, see <see cref="T:Loyc.Syntax.ParseNumberFlag"/>.</param>
        </member>
        <member name="M:Loyc.Syntax.ParseHelpers.SkipSpaces(Loyc.UString)">
            <summary>Returns a string with any spaces and tabs removed from the beginning.</summary>
            <remarks>Only ' ' and '\t' are treated as spaces.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParseNumberFlag">
            <summary>Flags that can be used with 
            <see cref="M:Loyc.Syntax.ParseHelpers.TryParseUInt(Loyc.UString@,System.UInt64@,System.Int32,Loyc.Syntax.ParseNumberFlag)"/>
            </summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSpacesInFront">
            <summary>Skip spaces before the number. Without this flag, initial spaces make parsing fail.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSpacesInsideNumber">
            <summary>Skip spaces inside the number. Without this flag, spaces make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.StopBeforeOverflow">
            <summary>Changes overflow handling behavior when parsing an integer,
            so that the result does not overflow (wrap), and the digit(s) at the 
            end of the string, that would have caused overflow, are ignored. In 
            this case, the return value is still false.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipUnderscores">
            <summary>Skip underscores inside number. Without this flag, underscores make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.SkipSingleQuotes">
            <summary>Skip single quotes inside number. Without this flag, single quotes make parsing stop.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParseNumberFlag.AllowCommaDecimalPoint">
            <summary>Whether to treat comma as a decimal point when parsing a float. 
            The dot '.' is always treated as a decimal point.</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralHandlerTable">
            <summary>A central class for keeping track of literal parsers and literal printers.</summary>
            <seealso cref="T:Loyc.Syntax.StandardLiteralHandlers"/>
        </member>
        <member name="P:Loyc.Syntax.LiteralHandlerTable.Parsers">
            <summary>A table of parsers indexed by type marker Symbol. 
            The <see cref="M:Loyc.Syntax.LiteralHandlerTable.AddParser(System.Boolean,Loyc.Symbol,System.Func{Loyc.UString,Loyc.Symbol,Loyc.Either{System.Object,Loyc.LogMessage}})"/> method is used to add an item to this collection.</summary>
        </member>
        <member name="P:Loyc.Syntax.LiteralHandlerTable.Printers">
            <summary>A table of printers indexed by Type or by type marker Symbol. 
            The <see cref="M:Loyc.Syntax.LiteralHandlerTable.AddPrinter(System.Boolean,Loyc.Symbol,System.Func{Loyc.Syntax.ILNode,System.Text.StringBuilder,Loyc.Either{Loyc.Symbol,Loyc.LogMessage}})"/> methods are used to add an item to this collection.</summary>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.AddParser(System.Boolean,Loyc.Symbol,System.Func{Loyc.UString,Loyc.Symbol,Loyc.Either{System.Object,Loyc.LogMessage}})">
            <summary>Adds a parser to the <see cref="P:Loyc.Syntax.LiteralHandlerTable.Parsers"/> collection.</summary>
            <param name="replaceExisting">If the specified type already has a printer 
            assigned to it, it will be replaced only if this flag is true.</param>
            <param name="typeMarker">The parser will be invoked by <see cref="M:Loyc.Syntax.LiteralHandlerTable.TryParse(Loyc.UString,Loyc.Symbol)"/>
            when this type marker Symbol matches the literal being parsed.</param>
            <param name="parser">A function that converts a UString to a value (object),
            or returns a <see cref="T:Loyc.LogMessage"/> if an error occurs. The type marker is
            also provided to the parser.</param>
            <returns>true if the printer was installed (if replaceExisting is true, 
            the method will return true unless the <c>type</c> is null.)</returns>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.AddPrinter(System.Boolean,Loyc.Symbol,System.Func{Loyc.Syntax.ILNode,System.Text.StringBuilder,Loyc.Either{Loyc.Symbol,Loyc.LogMessage}})">
            <summary>Adds a printer to the <see cref="P:Loyc.Syntax.LiteralHandlerTable.Printers"/> collection.</summary>
            <param name="replaceExisting">If the specified type already has a printer 
            assigned to it, it will be replaced only if this flag is true.</param>
            <param name="type">The printer will be invoked by <see cref="M:Loyc.Syntax.LiteralHandlerTable.TryPrint(Loyc.Syntax.ILNode,System.Text.StringBuilder)"/>
            when this Type or type marker Symbol matches the literal being printed.</param>
            <param name="printer">A printer function that prints into the provided 
            StringBuilder and returns null on success, or a description of the error 
            that occurred.</param>
            <returns>true if the printer was installed (if replaceExisting is true, 
            the method will return true unless the <c>type</c> is null.)</returns>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.AddPrinter(System.Boolean,System.Type,System.Func{Loyc.Syntax.ILNode,System.Text.StringBuilder,Loyc.Either{Loyc.Symbol,Loyc.LogMessage}})">
            <inheritdoc cref="!:AddPrinter(bool, Symbol, Func&lt;ILNode, Either&lt;UString, LogMessage&gt;&gt;)"/>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.CanParse(Loyc.Symbol)">
            <summary>Returns true if there is a parser function for the given type marker. Never throws.</summary>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.CanPrint(Loyc.Symbol)">
            <summary>Returns true if there is a printer function for the given type marker. Never throws.</summary>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.CanPrint(System.Type,System.Boolean)">
            <summary>Returns true if there is a printer function for the given type. Never throws.</summary>
            <param name="searchBases">Whether to search for printers among the base types of the given type.</param>
            <returns>True if type is not null and if there is a printer for that type.</returns>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.TryParse(Loyc.UString,Loyc.Symbol)">
            <inheritdoc cref="M:Loyc.Syntax.ILiteralParser.TryParse(Loyc.UString,Loyc.Symbol)"/>
        </member>
        <member name="M:Loyc.Syntax.LiteralHandlerTable.TryPrint(Loyc.Syntax.ILNode,System.Text.StringBuilder)">
            <summary>Searches <see cref="P:Loyc.Syntax.LiteralHandlerTable.Printers"/> for a printer for the value and uses it 
            to convert the value to a string. When a printer can be found both by type marker
            Symbol and by Type, the printer for the matching type marker is used (takes priority).
            The complete search order is (1) type marker (if any), (2) exact type, (3) base 
            classes and (4) interfaces, in that order.</summary>
            <param name="literal">A literal that you want to convert to a string.</param>
            <returns>Either the type marker for the literal, or an error message. 
            On return, the string form of the literal is appended to the StringBuilder.
            If an error occurs, it is possible that some kind of output was added to
            the StringBuilder anyway.</returns>
            <remarks>
            Note: this uses `Type.GetInterfaces` to obtain the list of interfaces, and this 
            list is officially not "in a particular order". It appears that the list is 
            constructed with some kind of depth-first search, so in simple cases derived 
            interfaces are searched before base interfaces, but if there are "diamonds" in
            the interface hierarchy then it will not be uncommon for a lower-level interface 
            to be checked before a higher-level one. Sorry.
            <para/>
            If a printer returns an error, this method tries to find other printers that might
            be able to print the value. If no printer succeeds, the <i>first</i> error that 
            occurred is returned.
            <para/>
            When the literal is null and there is no printer associated with literal.TypeMarker,
            this funtion produces no output and returns literal.TypeMarker.
            <para/>
            On success, the return value indicates which type marker is recommended based
            on the data type of the literal. This is not guaranteed to match the TypeMarker
            originally stored in the literal. It is recommended that language printers
            use the type marker stored in the literal (regardless of what this method
            returns) unless <c>literal.TypeMarker == null</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.StandardLiteralHandlers">
            <summary>
            A <see cref="T:Loyc.Syntax.LiteralHandlerTable"/> that is preinitialized with all standard 
            literal parsers and printers.
            </summary>
            <remarks>
            The following types are fully supported:
            <ul>
            <li>SByte (type marker: _i8)			  </li>
            <li>Int16 (type marker: _i16)		  </li>
            <li>Int32 (type marker: _i32)		  </li>
            <li>Int64 (type markers: _i64, _L)	  </li>
            <li>Byte  (type marker: _u8)		  </li>
            <li>UInt16 (type marker: _u16)		  </li>
            <li>UInt32 (type marker: _u32)		  </li>
            <li>UInt64 (type markers: _u64, _uL)  </li>
            <li>BigInteger (type marker: _z)	  </li>
            <li>Single (type markerS: _r32, _f)	  </li>
            <li>Double (type markerS: _r64, _d)	  </li>
            <li>Char   (type marker: c)			  </li>
            <li>String (type marker: empty string)</li>
            <li>Symbol (type marker: s)			  </li>
            <li>Loyc.@void (type marker: void)	  </li>
            <li>Boolean (type marker: bool)		  </li>
            <li>UString (no specific type marker) </li>
            <li>Byte[]  (type marker: bais) </li>
            </ul>
            There are also two general type markers, _ for a number of unspecified type,
            and _u for an unsigned number of unspecified size. In LES, any type marker 
            that is not on this list is legal, but will be left uninterpreted by default;
            <see cref="P:Loyc.Syntax.LNode.Value"/> will return a string of type <see cref="T:Loyc.UString"/>.
            <para/>
            The syntax corresponding to each type marker is standardized, meaning that 
            all implementations of LES2 and LES3 that can parse these types must do so 
            in exactly the same way.
            <para/>
            The Decimal and RegEx types have printers (with default type markers _m and 
            re) but no parser, because these type markers are not standardized.
            It's worth noting that regular expressions that are valid in one language 
            may be invalid in another, so to avoid parsing issues, re strings are not
            parsed to RegEx by default.
            <para/>
            The type marker "null" represents null, and the only valid value for the
            null and void type markers is an empty string (""). The only valid values
            for the bool type marker are "true" and "false" and case variations of
            these (e.g. "TRUE", "faLSE").
            <para/>
            Character literals are special in .NET because they parse into one of two 
            types, either Char or String, depending on whether the code point is less than
            0x10000 or not. Code points of 0x10000 or greater, sometimes called "astral"
            characters, do not fit in the .NET Char type so String is used instead. The
            type marker "c" indicates that the literal is not really a String.
            The character parser does return an error if the input is not a single code 
            point (i.e. two code units are fine if and only if they are a surrogate pair).
            However, the printer keyed to type string doesn't care if the type marker is
            "c" or not.
            <para/>
            Type markers begin with an underscore (_) for numeric types only. The 
            underscore enables special syntax in LES2 and LES3. For example, in LES3, 
            12345z is equivalent to _z"12345", but strings like re"123" can never be 
            printed in numeric form because their type marker does not start with an 
            underscore.
            <para/>
            The syntax of all integer types corresponds to the following case-
            insensitive regex:
            <code>
            	/^[\-\u2212]?({Digits}|0x{HexDigits}|0b{BinDigits})$/
            </code>
            where {Digits} means "[_']*[0-9][0-9_']*", {HexDigits} means 
            "[_']*[0-9a-f][0-9a-f_']*", and {BinDigits} means "[_']*[01][01_']*".
            While negative numbers can be indicated with the usual dash character '-',
            the minus character '\x2212' is also allowed. Numbers cannot contain spaces.
            Parsers will fail in case of overflow, but a BigInteger cannot overflow.
            <para/>
            The syntax of a floating-point type corresponds to one of the following 
            case-insensitive regexes for decimal, hexadecimal, binary and non-numbers 
            respectively:
            <code>
            	/^[\-\u2212]?({Digits}(\.[0-9_']*)?|\.{Digits})(e[+-]?{Digits})?$/
            	/^[\-\u2212]?0b({BinDigits}(\.[01_']*)?|\.{BinDigits})(p[+-]?{BinDigits})?$/
            	/^[\-\u2212]?0x({HexDigits}(\.[0-9a-f_']*)?|\.{HexDigits})(p[+-]?{HexDigits})?$/
            	/nan|[\-\u2212]?inf/i
            </code>
            These require that any number contains at least one digit, but this digit can
            appear after the decimal point (.) if there is one. There can be any quantity
            of separator characters, but no spaces. The final regex allows NaN and 
            infinities to be parsed and printed.
            <para/>
            Given these patterns, integers are also detected as floating-point numbers. 
            If a floating-point number is printed without a type marker, or if the type 
            marker is _, the printer recognizes that it must add the suffix ".0" if 
            necessary so that the number will be treated as floating point when it is 
            parsed again later.
            <para/>
            Finally, I will point out that LES3 parsers and printers have some special 
            behavior related to string parsing and printing in environments that use
            UTF-16. There are two kinds of numeric escape sequences in LES3 strings and
            identifiers: two-digit sequences which look like \xFF, and unicode escape
            sequences with four to six digits, i.e. \u1234 or \U012345. LES3 strings 
            and identifiers must be interpreted as byte sequences, with \x escape 
            sequences representing raw bytes and \u escape sequences representing 
            proper UTF-8 characters. For UTF-16 environments like .NET, Loyc defines a 
            reversible (lossless) transformation from these byte sequences into UTF-16.
            \x sequences below \x80 are treated as normal ASCII characters, while \x 
            sequences above \x7F represent raw bytes that may or may not be valid 
            UTF-8. When a sequence is valid UTF-8, e.g. "\xE2\x80\xA2", it is 
            translated into the appropriate UTF-16 character (in this case "•" or 
            "\u2022"). Otherwise, the byte becomes an invalid (unmatched surrogate) 
            code unit in the range 0xDC80 to 0xDCFF, e.g. "\x99" becomes 0xDC99 
            inside a UTF-16 string. However, this implies that the UTF-8 byte sequence 
            "\xEF\xBF\xBD", which normally represents the same invalid surrogate 
            \uDC99, cannot also be translated to 0xDC99 in UTF-16. Instead it is 
            treated as three independent bytes which become a sequence of three 
            UTF-16 code units, 0xDCEF 0xDCBF 0xDCBD. Upon translation back to UTF-8,
            these become "\xEF\xBF\xBD" as expected. Furthermore, an LES3 ASCII 
            escape sequence like "\uDC99", which is equivalent to "\xEF\xBF\xBD",
            should actually produce three code units in a UTF-16 environment 
            (printed as "\uDCEF\uDCBF\uDCBD" in C# or Enhanced C#).
            <para/>
            However, none of this trickery necessarily needs to be handled by the 
            parsers and printers in this class, because the challenge appears at
            a different level. Namely, this trickery applies in the LES3 parser when 
            ASCII escape sequences are converted to invalid surrogates in UTF-16,
            which happens before the string reaches a parser in this class. Also,
            some trickery may be done by the LES3 printer after a string is printed 
            by this class. Finally, this special behavior applies only to UTF-16 
            environments (and UTF-8 environments like Rust that prohibit byte 
            sequences that are not valid UTF-8). No special-case code is necessary 
            in enviroments that use byte arrays for strings, because the purpose of
            this trickery is to allow LES3 strings to faithfully represent arbitrary 
            byte sequences in addition to Unicode strings.
            </remarks>
            <seealso cref="T:Loyc.Syntax.ParseHelpers"/>
            <seealso cref="T:Loyc.Syntax.PrintHelpers"/>
        </member>
        <member name="P:Loyc.Syntax.StandardLiteralHandlers.DigitSeparator">
            <summary>Gets or sets a character used to separate groups of digits.
            It must be must be _ or ' or null, and it is inserted every 3 digits in 
            decimal numbers (e.g. 1_234_567), every 4 digits in hex numbers (e.g. 
            0x1234_5678), or every 8 digits in binary numbers (e.g. 11_10111000).
            </summary>
        </member>
        <member name="T:Loyc.Syntax.StandardTriviaInjector">
            <summary>Encapsulates an algorithm that consumes trivia (comments and 
            newlines) from a list and adds it as trivia attributes into LNodes. This
            makes it possible to preserve comments and newlines independently of the
            language parser, so that the parser need not be specifically designed to 
            preserve them.</summary>
            <remarks>
            Usage: Call the constructor, then call <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>.
            See <see cref="T:Loyc.Syntax.AbstractTriviaInjector`1"/> for more information.
            <para/>
            In brief, given input code with C-style comments like
            <pre>
            {
            	// Leading Comment 1
            	/* Leading Comment 2 * /
            	/* Leading Comment 3 * / x = y; // Trailing Comment 1
            	/* Trailing Comment 2 * /
            	
            	y = z; TheEnd();
            }
            </pre>
            [NOTE: the space in "* /" is a workaround for a serious bug in Doxygen, the html doc generator]
            
            The output, expressed in LESv2, is
            <pre>
            {
            	@[@%SLComment(" Leading Comment 1"),
            	  @%MLComment(" Leading Comment 2 "),
            	  @%newline,
            	  @%MLComment(" Leading Comment 3 "),
            	  @%trailing(
            	    @%SLComment(" Trailing Comment 1"),
            	    @%MLComment(" Trailing Comment 2 "),
            	    @%newline)]
            	x = y;
            	y = z;
            	@[@%appendStatement] TheEnd();
            }
            </pre>
            By default, printers should add newlines between statements within a braced 
            block. Therefore, this class does not add trivia to mark a single newline 
            between statements; instead, it adds an %appendStatement attribute 
            when the expected newline prior to a statement in a braced block was NOT 
            present. Also, a newline is expected after a single-line comment and no 
            <c>%newline</c> is created for the expected newline.
            <para/>
            Finally, since printers typically add a newline before the closing brace by
            default, this class avoids adding an attribute for that newline, if present.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.#ctor(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>Initializes <see cref="T:Loyc.Syntax.StandardTriviaInjector"/>.</summary>
            <param name="sortedTrivia">A list of trivia that will be injected into the 
            nodes passed to <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>. Normally,
            text of comments is extracted from the provided <see cref="T:Loyc.Syntax.ISourceFile"/>,
            but comment tokens could instead store their text as a string in their
            <see cref="P:Loyc.Syntax.Lexing.Token.Value"/>.</param>
            <param name="sourceFile">This is used as the source file of the <see cref="P:Loyc.Syntax.LNode.Range"/> 
              of all trivia attributes that the algorithm injects.</param>
            <param name="newlineTypeInt">A token is interpreted as a newline when this value equals 
              <see cref="P:Loyc.Syntax.Lexing.Token.TypeInt"/>.</param>
            <param name="mlCommentPrefix">If a token's text begins with this prefix it is assumed to be 
              a multi-line comment and the prefix is removed.</param>
            <param name="mlCommentSuffix">If a multi-line comment's text ends with this suffix, 
              the suffix is removed.</param>
            <param name="slCommentPrefix">If a token's text begins with this prefix it is assumed to be 
              a single-line comment and the prefix is removed.</param>
            <param name="topLevelIsBlock">If true, newlines are expected between items at the top level, 
              like in a braced block, so that, for example, if two consecutive nodes are on the same line,
              an @appendStatement trivia attribute will be attached to the second one.</param>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.HasImplicitLeadingNewline(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Int32)">
            <summary>Called to find out if a newline is to be added implicitly 
            before the current child of the specified node.</summary>
            <returns>By default, returns true if the node is a braced block.</returns>
        </member>
        <member name="M:Loyc.Syntax.StandardTriviaInjector.MakeTriviaAttribute(Loyc.Syntax.Lexing.Token)">
            <summary>Called to transform a trivia token into a trivia attribute.</summary>
            <remarks>If a trivia token is not recognized, null is returned to ignore the trivia.</remarks>
        </member>
        <member name="T:Loyc.Syntax.AbstractTriviaInjector`1">
             <summary>Encapsulates an algorithm that consumes trivia (comments and 
             newlines) from a list and adds it as trivia attributes into LNodes.</summary>
             <remarks>
             Call <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/> to invoke the algorithm. One must also write a
             derived class that knows how to interpret the trivia and associate it with
             a specific <see cref="T:Loyc.Syntax.LNode"/>, or use the standard derived class 
             <see cref="T:Loyc.Syntax.StandardTriviaInjector"/>.
             <para/>
             The algorithm is designed to postprocess output from a parser that works in
             a typical way. The lexer for your language needs to follow the following rules:
             
             <ul>
             <li>It must not include the newline character in the range of a single-line 
             comment.</li>
             <li>Generally, newlines (including the newline after a single-line comment)
             should be included in the trivia list, as the algorithm relies on newline trivia
             to notice when a new line is starting. Notably, a comment/trivia right after a 
             statement (e.g. on the same line) should normally be associated with that
             statement; if this class is unaware of the newline it will be associated with
             the next statement instead.</li>
             </ul>
             
             Typically one will wrap the lexer in <see cref="T:Loyc.Syntax.Lexing.TriviaSaver"/>, which 
             saves trivia while filtering out whitespace so that the parser doesen't see it.
             <para/>
             Your language's parser needs to follow the following rules:
             
             <ul>
             <li>The parser should assign minimal boundaries to each node: the 
             <see cref="P:Loyc.Syntax.LNode.Range"/> should not be wider than necessary. If there is 
             a comment before an expression like <c>/* ! * / x + y</c>, the parser should 
             not include the comment as part of the range unless it wants the comment to 
             be associated with a child node (<c>x</c>) instead of with the entire 
             expression (<c>x + y</c>).</li>
             <li>However, if a node has normal (non-trivia) attributes attached to it, 
             the Range of the node must include those attributes. If your parser fails 
             to do this, one symptom can be that a newline after an attribute "moves up" 
             in the attribute list so it appears before the attribute.</li>
             <li>The parser should use <see cref="M:Loyc.Syntax.LNodeFactory.InParens(Loyc.Syntax.LNode)"/> to place a
             node in parentheses and include the index of the opening and closing parens.</li>
             <li>If an expression/statement is terminated by a semicolon/comma, it's 
             best (but not crucial) to include the semicolon/comma in the LNode.Range, 
             but if a statement is terminated by a newline, the newline should not be 
             included in the range. If general, when the terminator is included in the 
             range, then any comment that appears before the terminator is attached
             to the final child node rather than to the node as a whole. (e.g. in 
             <c>x = y /*y* /;</c>, the comment is associated with <c>y</c> if the
             comment is within the range of the statement as a whole.)</li>
             </ul>
             This example shows how comments are associated with nodes:
             [NOTE: the space in "* /" is a workaround for a serious bug in Doxygen, the html doc generator]
             <pre>
             // Comment attached to block
             {
               // Comment attached to Foo() call
               Foo(
            		// Comment attached to «argument1 + 1». Note that the comma is 
            		// generally invisible to the injector since it is not part of the LNode 
            		// tree, so the 1st and 2nd comments will both be attached to the sum-
            		// expression as a whole.
            		argument1 + 1 /*1st comment* /, // 2nd comment
            		// Comment attached to «argument2 + 2»
            		argument2 + 2); // Comment attached to Foo() call
            	  Area = 3.14159265/*PI* /  *  /*radius* /r**2;
            	  // Comment attached to «Area =» statement, preceded by newline trivia?
            
            	  // Comment attached to Bar()
            	  @BarAttr // Comment attached to BarAttr attribute
            	  Bar();
            	  
            	  // Comment attached to Bar() because there are no statements afterward
             }
             </pre>
             When there is a single newline between two nodes, <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/> will
             associate it with the second one. When there is a blank line between two 
             nodes (two newlines), the first newline (and any before) is associated with 
             the first node and the second newline (and any following) is associated with 
             the second.
             </remarks>
        </member>
        <member name="P:Loyc.Syntax.AbstractTriviaInjector`1.SortedTrivia">
            <summary>List of trivia to be injected by <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})"/>. Must be sorted.</summary>
        </member>
        <member name="P:Loyc.Syntax.AbstractTriviaInjector`1.NextIndex">
            <summary>Index of next trivia to be injected.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.#ctor(Loyc.Collections.IListSource{`0})">
            <summary>Initializes the <see cref="P:Loyc.Syntax.AbstractTriviaInjector`1.SortedTrivia"/> property.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.GetTriviaToAttach(Loyc.Syntax.LNode,Loyc.Collections.IListSource{`0},Loyc.Syntax.AbstractTriviaInjector{`0}.TriviaLocation,Loyc.Syntax.LNode,System.Int32)">
            <summary>Derived class translates a list of trivia (tokens) into appropriate 
            trivia attributes. This will be called for leading trivia before trailing 
            trivia.</summary>
            <param name="node">The node.</param>
            <param name="trivia">Trivia to be associated with <c>node</c>.</param>
            <param name="loc">Location of the trivia. For a given node, the base class
            calls this method at most once for each value of <see cref="T:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation"/>.
            </param>
            <param name="parent">(Original version of) parent of <c>node</c>.</param>
            <param name="indexInParent">Index of <c>node</c> within <c>parent</c>.</param>
            <returns>A list of trivia attributes that should be attached to the node.</returns>
            <remarks>This method will be called for a node when there is no trivia 
            associated with that node; the derived class may, for example, want to add 
            `%appendStatement` in certain cases.</remarks>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Leading">
            <summary>Trivia that appeared before a node</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Trailing">
            <summary>Trivia associated with a node that came before it</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.TrailingExtra">
            <summary>Trivia attached to the last node in an argument list or last statement in a block</summary>
        </member>
        <member name="F:Loyc.Syntax.AbstractTriviaInjector`1.TriviaLocation.Ambiguous">
            <summary>The trivia begins within the range of an identifier or literal. 
            This occurs, for example, if a list of arguments or attributes includes a
            comma in the range of each argument, and there is trivia before the comma,
            e.g. in <c>Foo(x/* trivia * /, y);</c>, this occurs if the range of <c>x</c> 
            includes the comma token. The trivia injector is not aware of <c>x</c> or
            the comma; all it knows is that the trivia is "inside" the range of <c>x</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.ProcessChildrenOfOneLiner(Loyc.Syntax.LNode@)">
            <summary>This method is called when a node has no newlines or comments within it
            (although the node may still have a leading or trailing comment). The method
            should add %appendStatement trivia inside blocks in the node, if necessary.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.GetRange(`0)">
            <summary>Gets the <see cref="T:Loyc.Syntax.SourceRange"/> for an element of trivia.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.IsNewline(`0)">
            <summary>Returns true if the trivia represents a newline, false otherwise.</summary>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.GetEmptyResultSet">
            <summary>A method called to create a virtual node, in order to apply trivia to a 
            source file that is completely empty except for trivia.</summary>
            <remarks>Default implementation attaches all trivia to a "missing" node 
            (zero-length identifier). If this method returns null, the source file will truly 
            be empty (containing no trivia either).</remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.DoneAttaching(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Int32)">
            <summary>This method is called after a node has been processed and any 
            applicable trivia was attached.</summary>
            <param name="node">Node (after trivia attached)</param>
            <param name="parent">Parent of <c>node</c> (old version, before changes to children are applied)</param>
            <param name="indexInParent">Index of <c>node</c> within <c>parent</c>.</param>
            <returns>Should return <c>node</c> or an altered version of <c>node</c>.</returns>
            <remarks>This method gives the derived class one final chance to 
            rearrange or alter the interpretation of the attached trivia. Note
            that this method may be called on some nodes to which trivia was
            not attached, when siblings of the same parent had trivia attached.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.Run(System.Collections.Generic.IEnumerator{Loyc.Syntax.LNode})">
            <summary>Attaches trivia to the input nodes provided.</summary>
            <param name="nodes">List of input nodes. This method calls nodes.MoveNext()
            before calling nodes.Current.</param>
            <remarks>Trailing trivia after all nodes is attached to the final node. If 
            <c>nodes</c> is empty then <see cref="M:Loyc.Syntax.AbstractTriviaInjector`1.GetEmptyResultSet"/> is called to
            create a dummy node and attach all trivia to it.</remarks>
        </member>
        <member name="M:Loyc.Syntax.AbstractTriviaInjector`1.RunCore(System.Collections.Generic.IEnumerator{Loyc.Pair{Loyc.Syntax.LNode,System.Int32}},Loyc.Syntax.LNode)">
            <summary>Core trivia associaton algorithm.</summary>
            <remarks>
            NOTE: the enumerator may DRIVE lexing and actually cause the trivia list
            (SortedTrivia) to increase in size. For this reason, this algorithm is careful
            to call nodes.MoveNext() BEFORE getting the current trivia. I'm not sure if this
            precaution is sufficient to preserve trivia in all "streaming" cases, but it
            has worked fine up to now.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`3">
            <summary>An implementation of the LLLPG Parser API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.BaseParserForList`3"/>.
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class does not expect it to
            ever be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.ParserSource`3.TokenTypeToString">
            <summary>Converts from MatchType (usually integer) to string (used in 
            error messages).</summary>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Skip">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`2">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
            <typeparam name="MatchType">Data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (often set to int).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`1">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.Precedence">
            <summary>A four-byte tuple that represents the precedence and miscibility 
            of an operator.</summary>
            <remarks>
            Precedences encode knowledge like the fact that <c>x &amp; y == z</c> will 
            be parsed as <c>x &amp; (y == z)</c> in C#. An operator's precedence is 
            encoded in the two numbers, <see cref="F:Loyc.Syntax.Precedence.Left"/> and <see cref="F:Loyc.Syntax.Precedence.Right"/>.  
            For typical operators which are left-associative, Left and Right are the 
            same. However, some operators have different precedence on the left than 
            on the right, a prime example being the => operator: <c>x = a => y = a</c> 
            is parsed <c>x = (a => (y = a))</c>; it has very high precedence on the 
            left, but very low precedence on the right.
            <para/>
            To understand how this works, remember that a parser scans from left to 
            right. Each time it encounters a new operator, it needs to figure out 
            whether to include that operator in the current (inner) expression or 
            whether to "complete" the inner expression so that the operator can be 
            bound to an outer expression instead. The concept of a "precedence floor" 
            can be used to make this decision.
            <para/>
            For example, suppose we start parsing the expression <c>-a.b + c * d + e</c>.
            The parser sees "-" first, which must be a prefix operator since there is 
            no expression on the left. The <see cref="F:Loyc.Syntax.Precedence.Right"/> precedence of unary 
            '-' is 90 in EC#, so that will be the "precedence floor" to parse the 
            right-hand side. Operators above 90 will be permitted in the right-hand 
            side; operators at 90 or below will not.
            <para/>
            The next token is 'a', which is an expression by itself and doesn't have 
            any precedence, so it becomes the initial right-hand expression of '-'.
            Next we have '.', which has a <see cref="F:Loyc.Syntax.Precedence.Left"/> precedence of 100, which 
            is above the precedence floor of 90 so it can be bound to 'a'. The 
            precedence floor (PF) is raised to 100, and the next token 'b' is bound to 
            '.'.
            <para/>
            However, the next token '+' (which must be the binary operator rather than 
            the prefix operator, because there is an expression on the left) cannot be 
            accepted with its precedence of 60. Therefore the expression "a.b" is 
            deemed complete, and the PF is lowered back to 90. Again 60 is less than 
            90, so the expression "-a.b" is also deemed complete and the PF drops to 
            int.MinValue. This expression becomes the left-hand side of the '+' 
            operator. The PF rises to 60, and "c * d" becomes a subexpression because
            the precedence of '*' is 70 > 60. However, next we have '+' with 
            precedence 60, which is not above the PF of 60. Therefore, the 
            subexpression "c * d" is deemed complete and the PF lowers to int.MinValue
            again. Now the '+' can be accepted with a left-hand side of <c>(-(a.b)) + 
            (c * d)</c>, and the right-hand side is, of course, 'e', so the completed
            expression is <c>((-(a.b)) + (c * d)) + e</c>. Hope that helps!
            <para/>
            Notice that <c>a + b + c</c> is parsed <c>(a + b) + c</c>, not 
            <c>a + (b + c)</c>. This is the natural result when the operator's 
            precedence is the same on the left and on the right. However, <c>a = b = c</c>
            is parsed <c>a = (b = c)</c>, because its precedence is 1 on the left and 
            0 on the right. When the parser sees the first '=' it sets the PF to 0 
            because it is about to parse the right side. When it encounters the second 
            '=', the precedence of the Left side of that operator is 1 which is higher 
            than the current PF (0) so it is included in the right-hand side of the 
            first '='. This behavior is called "right associativity"; 
            <see cref="P:Loyc.Syntax.Precedence.IsRightAssociative"/> returns true when <c>Left > Right</c>.
            <para/>
            Prefix and suffix operators only have one "side"; you can imagine that the 
            unused side (e.g. the left side of prefix -) has infinite precedence, so 
            that EC# could parse $-x as $(-x) even though the precedence of '-' is 
            supposedly lower than '$'.
            <para/>
            Some languages have a conditional operator (a?b:c) with three parts. In 
            the middle part, the PF must drop to Precedence.MinValue so that it is 
            possible to parse <c>a?b=x:c</c> even though '=' supposedly has lower 
            precedence than the conditional operator. Note that <c>a=b ? c=d : e=f</c> 
            is interpreted <c>a=(b ? c=d : e)=f</c>, so you can see that the precedence 
            of the conditional operator is higher at the "edges".
            <para/>
            The above explanation illustrates the meaning of Left and Right from the
            perspective of a parser, but an actual parser may or may not use the PF 
            concept and <c>Precedence</c> objects.
            <para/>
            In summary: <see cref="F:Loyc.Syntax.Precedence.Left"/> and <see cref="F:Loyc.Syntax.Precedence.Right"/> represent the 
            precedence of the left and right side of a binary operator. A parser can 
            keep track of a number called the "precedence floor" or PF, which has its 
            minimum value when parsing starts. When a binary operator <c>Op</c> is 
            encountered, the parser should "accept" the operator when <c>O.Left > PF</c>
            and, if it accepts the operator, set <c>PF = O.Right</c> temporarily as it 
            parses the right side of the operator.
            <para/>
            This struct contains two other numbers, <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/>,
            which are a precedence range that determines whether and how the operator 
            can be mixed with other operators, as explained below.
            <para/>
            A printer (which writes a syntax tree as text) has a different way of analyzing
            precedence. It starts with a known parse tree and then has to figure out 
            how to output something that the parser will reconstruct into the original
            tree. This is more difficult if perfect round-tripping is required: parentheses
            are encoded in the Loyc tree as a <c>%inParens</c> attribute, so if perfect
            round-tripping is desired, the printer cannot simply put everything in parens 
            "just to be safe".
            <para/>
            The LES and EC# printers have two ways of printing any expression tree: (1) 
            with operators (e.g. a+b), and (2) with prefix notation (e.g. `'+`(a, b)).
            The tree <c>`'+`(`'*`(a, b), c)</c> will be printed as "a*b+c" (unless prefix
            notation is specifically requested) because the precedence rules allow it,
            but <c>`'*`(`'+`(a, b), c)</c> will be printed as <c>`'+`(a, b)*c</c> because 
            both "a+b*c" and "(a+b)*c" are different from the original tree.
            <para/>
            While a parser proceeds from left to right, a printer proceeds from parents
            to children. So the printer for `'*`(`'+`(a, b), c) starts at <c>`'*`</c> with no 
            precedence restrictions, and roughly speaking will set the precedence floor
            to <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Multiply in order to print its two children.
            Since the precedence of `'+` (Add) is below Multiply, the + operator is not
            allowed in that context.
            <para/>
            Printing has numerous "gotchas"; the ones related to precedence are
            <ol>
            <li>Although <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Add has the "same" precedence on the
                Left and Right, <c>`'-`(`'-`(a, b), c)</c> can be printed <c>a - b - c</c> but
                <c>`'-`(a, `'-`(b, c))</c> would have to be printed <c>a - `'-`(b, c)</c> 
                instead. Clearly, the left and right sides must be treated somehow
                differently.</li>
            <li>Similarly, the different arguments in <c>a?b:c</c> and <c>a=>b</c> must
                be treated differently. And careful handling is needed for the dot 
                operator in particular due to its high precedence; e.g. <c>`'.`(a(b))</c> 
                cannot be printed <c>.a(b)</c> because that would mean <c>`'.`(a)(b)</c>.</li>
            <li>The LES parser, at least, allows a prefix operator to appear on the 
                right-hand side of any infix or prefix operator, regardless of the 
                precedence of the two operators; "$ ++x" is permitted even though ++ has
                lower precedence than $. Another example is that <c>a.-b.c</c> can be 
                parsed with the interpretation <c>a.(-b).c</c>, even though '- has 
                lower precedence than '$. Ideally the printer would replicate this 
                rule, but whether it does ot not, it also must take care that 
                <c>`'.`(a, -b.c)</c> is not printed as <c>a.-b.c</c> even though the 
                similar expression <c>`'*`(a, `'-`(b.c))</c> can be printed as <c>a*-b.c</c>.</li>
            <li>Prefix notation is needed when an operator's arguments have attributes;
                <c>`'+`([Foo] a, b)</c> cannot be printed <c>[Foo] a + b</c> because
                that would mean <c>[Foo] `'+`(a, b)</c>.</li>
            </ol>
            
            <h3>Printing and parsing are different</h3>
            
            This type contains different methods for printers and parsers. A basic 
            difference between them is that printers must make decisions (of whether
            an operator is allowed or not in a given context) based on both sides of
            the operator and both sides of the context (Left and Right), while parsers
            only have to worry about one side. For example, consider the following 
            expression:
            <code>
                a = b + c ?? d
            </code>
            When the parser encounters the "+" operator, it only has to consider 
            whether the precedence of the <i>left-hand side</i> of the "+" operator
            is above the <i>right-hand side</i> of the "=" operator. The fact that
            there is a "??" later on is irrelevant. In contrast, when printing the 
            expression "b + c", both sides of the subexpression and both sides of the 
            context must be considered. The right-hand side is relevant because if 
            the right-hand operator was "*" instead of "??", the following printout 
            would be wrong:
            <code>
                a = b + c * d   // actual syntax tree: a = `'+`(b, c) * d
            </code>
            The same reasoning applies to the left-hand side (imagine if "=" was 
            "*" instead.)
            <para/>
            So, naturally there are different methods for parsing and printing.
            For printing you can use <see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/>, <see 
            cref="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)"/> and <see cref="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)"/>, while for parsing you 
            only need <see cref="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)"/> (to raise the precedence floor, simply
            replace the current <see cref="T:Loyc.Syntax.Precedence"/> value with that of the new 
            operator). If one chooses to use this type to represent the precedence 
            floor in a parser, the "current" precedence is represented by <see 
            cref="F:Loyc.Syntax.Precedence.Right"/>; the value of <see cref="F:Loyc.Syntax.Precedence.Left"/> doesn't matter.
            <para/>
            Both printers and parsers can use <see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>.
            
            <h3>Miscibility (mixability)</h3>
            
            <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/> don't affect how operators are
            parsed into a tree, but are used to request a warning or error if operators
            are mixed improperly. If one operator's range overlaps another AND (the 
            ranges are not equal OR <c>Lo > Hi</c>), then the two operators are 
            immiscible. For example, == and != have the same precedence in EC#, 38..39, 
            so they can be mixed with each other, but they cannot be mixed with &amp; 
            which has the overlapping range 32..45 (this will be explained below.)
            Normally Lo and Hi are set to <c>Min(Left,Right)</c> and <c>Max(Left,Right)</c>
            respectively, but this is not required--in particular, any pair where
            <c>Lo > Hi</c> is used to indicate that the operator cannot be mixed with 
            other operators of the same precedence, even though it can (perhaps) be 
            mixed with others of different precedence. This is called non-associativity. 
            For example, in PHP are not allowed to write an expression such as 
            <c>x > y >= z</c>; to represent this, operators <c>></c> and <c>>=</c> 
            should make <c>Lo > Hi</c>.
            <para/>
            Certain operators should not be mixed because their precedence was originally 
            chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is 
            actually parsed x &amp; (3 == 1). To allow the precedence to be repaired 
            eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will 
            warn you if you have mixed operators improperly. PrecedenceRange describes 
            both precedence and miscibility with a simple range of integers. As mentioned
            before, two operators are immiscible if their ranges overlap but are not 
            identical.
            <para/>
            In LES, the precedence range feature (a.k.a. immiscibility) is also used to 
            indicate that a specific precedence has not been chosen for an operator. 
            If a precedence is chosen in the future, it will be somewhere within the 
            range.
            
            <h3>Overall Range</h3>
            
            By convention, precedence scales range from about 0 to about 100.
            The precedence numbers are stored in this structure as <c>sbyte</c>s, so 
            <c>Left</c>, <c>Right</c>, <c>Lo</c>, and <c>Hi</c> must be between -128 
            and 127.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32)">
            <summary>Initializes a left-associative operator with the specified precedence.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32)">
            <summary>Initializes an operator with different precedence on the left 
            and right sides. For a right associative operator, conventionally 
            <c>right = left-1</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Initializes an operator with the given precedence on the
            left and right sides, and the given immiscibility range (see 
            documentation of this type).</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Lo">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Hi">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Left">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Right">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the left side of an operator.</summary>
            <param name="outerContext"></param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the right side of an operator.</summary>
            <param name="outerContext">Context in which this operator is being printed</param>
            <returns></returns>
        </member>
        <member name="P:Loyc.Syntax.Precedence.IsRightAssociative">
            <summary>Returns true if this object represents a right-associative 
            operator such as equals (x = (y = z)), in contrast to left-
            associative operators such as division ((x / y) / z).</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Returns true if an infix operator 
            with this precedence can appear in the specified context.</summary>
            <remarks>Miscibility must be checked separately (<see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence,System.Boolean)">
            <summary>For use in printers. Returns true if an operator with 
            this precedence can appear in the specified context (ignoring 
            miscibility).</summary>
            <param name="prefix">It is assumed that the left side of a 
            prefix operator has "infinite" precedence so when this flag is
            true, only the right side is checked.</param>
            <remarks>This prefix rule is used by the EC# printer but is not 
            allowed by all languages (if in doubt, set prefix=false).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)">
            <summary>Returns true if an operator with this precedence is miscible
            without parenthesis with the specified other operator.</summary>
            <remarks><see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/> is for parsability, 
            this method is to detect a deprecated or undefined mixing of operators.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)">
            <summary>For use in parsers. Returns true if 'rightOp', an operator
            on the right, has higher precedence than the current operator 'this'.</summary>
            <returns><c>rightOp.Left > this.Right</c></returns>
        </member>
        <member name="T:Loyc.Syntax.LNodeRangeMapper">
            <summary>Helps map locations (such as error locations) from a file (usually an 
            output file) to an <see cref="T:Loyc.Syntax.LNode"/> (see Remarks).</summary>
            <remarks>
            A common scenario is that you've written code in Enhanced C# and then sent it 
            through LeMP to produce an output file. The C# compiler produces error messages 
            with locations in the output file, but you would like to see what part of the
            original Enhanced C# file is associated with those errors. The LeMP Visual 
            Studio extension could use this class to help obtain this information.
            <para/>
            This requires (1) keeping track of the relationship between the output file
            and the original list of <see cref="T:Loyc.Syntax.LNode"/>s that contain source locations, and
            (2) an algorithm to map error locations back to source nodes and locations.
            Feature (1) is provided by individual node printers and can be requested via
            <see cref="P:Loyc.Syntax.ILNodePrinterOptions.SaveRange"/>. This class provides Feature (2).
            In addition, locations provided by a compiler tend to be line/column pairs
            instead of indexes, so (3) an <see cref="T:Loyc.Syntax.ILineToIndex"/> implementation is
            needed to convert line/column pairs to indexes.
            <para/>
            Mapping back to a source location is trickier than mapping back to a source 
            node, mainly because transformations (such as those done by LeMP) can 
            introduce synthetic nodes, duplicate nodes, and nodes from other files. 
            The node that best matches the output location might be something that has
            no location in the current source file, or no location in any source file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeRangeMapper.SaveRange(Loyc.Syntax.ILNode,Loyc.Syntax.IndexRange,System.Int32)">
            <summary>Associates a node with a range.</summary>
            <remarks>Typically this method is set as the value of 
            <see cref="P:Loyc.Syntax.ILNodePrinterOptions.SaveRange"/> so that range info is captured
            while converting a node to text. This class does not need or use the third 
            parameter (depth).</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNodeRangeMapper.SavedRangeCount">
            <summary>Gets the number of ranges that were stored with <see cref="M:Loyc.Syntax.LNodeRangeMapper.SaveRange(Loyc.Syntax.ILNode,Loyc.Syntax.IndexRange,System.Int32)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeRangeMapper.FindRelatedNodes(Loyc.Syntax.IndexRange,System.Int32)">
            <summary>Gets a list of nodes close to the requested range, ordered by similarity 
            so that the first item in the returned list is the best result.</summary>
            <returns>A list of nodes and their ranges, sorted by similarity to the targetRange
            (most similar first), and limited in size as requested. The nodes and ranges must
            have been previously saved via <see cref="!:SaveRange(ILNode, IndexRange)"/>.</returns>
        </member>
        <member name="M:Loyc.Syntax.LNodeRangeMapper.FindMostUsefulRelatedNode(Loyc.Syntax.IndexRange,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Selects the "closest" node to the target range, under the constraint 
            that, if possible, you want to find a node belonging to a particular file and
            with a valid (non-negative) StartIndex. If there are no good results, this 
            method will return a poor result instead (e.g. a node from a different file).</summary>
            <returns>The best node and its range in the file being searched (not sourceFile, but
            the file for which ranges were saved via <see cref="!:SaveRange(ILNode, IndexRange)"/>.)</returns>
        </member>
        <member name="M:Loyc.Syntax.LNodeRangeMapper.GetMismatchScore(System.Collections.Generic.KeyValuePair{System.Int32,Loyc.Pair{Loyc.Syntax.ILNode,System.Int32}},Loyc.Syntax.IndexRange)">
            <summary>Scores the extent to which a location-table item does NOT match the source file.</summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper`1">
            <summary>
            Helper class for mapping from indexes to SourcePos and back.
            </summary><remarks>
            This class's job is to keep track of the locations of line breaks in order
            to map from indices to SourcePos objects or vice versa. Converting indexes 
            to SourcePos is commonly needed for error reporting; lexers, parsers and 
            code analyzers typically use indexes (simple integers) internally, but must
            convert to SourcePos in order to communicate with the end user. Occasionally
            one may wish to convert in the reverse direction also (SourcePos to index).
            <para/>
            Line breaks themselves are classified as being at the end of each line.
            So if the file is "Bob\nJoe", <c>IndexToLine(3).Line == 1</c>, not 2.
            <para/>
            The outputs are immutable and this class assumes the input file never 
            changes. However, this class is not entirly multi-thread-safe until the 
            entire input file or string has been scanned, since the list of line breaks
            is built on-demand, without locking.
            </remarks>
            <typeparam name="CharSource">A type that implements <c>IListSource(Char)</c>.
            Originally this class did not have any type parameters and dealt with
            <c>IListSource(Char)</c>, but it was made generic so that one could wrap
            value types such as <c>UString</c> without boxing.
            </typeparam>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.#ctor(`0,Loyc.Syntax.ILineColumnFile)">
            <summary>Initializes CharIndexPositionMapper.</summary>
            <param name="source">An immutable list of characters.</param>
            <param name="startingPos">Optional. The first character of <c>source</c> 
            will be considered to have the file name and line number specified by 
            this object. If this is null, IndexToLine() will return a blank file 
            name ("").</param>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.Reset(`0,System.String)">
            <summary>Reinitializes the object (as though the constructor were called again).</summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper">
            <summary>Synonym for <c>IndexPositionMapper&lt;IListSource&lt;char>></c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceFileWithLineRemaps">
            <summary>An wrapper around ISourceFile that applies line remapping 
            information (if the source file uses it).</summary>
            <remarks>
            A preprocessor that supports #line may wrap the original <see 
            cref="T:Loyc.Syntax.ISourceFile"/> in one of these, even when the source file 
            doesn't use #line.
            <para/>
            Call Remaps.AddRemap() and, optionally, Remaps.EndRemap(), to add each
            mapping.
            <para/>
            <see cref="T:Loyc.Syntax.ISourceFile"/> includes <see cref="T:Loyc.Syntax.IIndexPositionMapper"/>
            which allows reverse-mapping from line/position back to index. However,
            a position derived from #line information may be ambiguous (does not 
            always have a unique reverse mapping), and I'd rather avoid the work of 
            reverse mapping anyway. So this class does not perform reverse mapping,
            but forward mappings return <see cref="T:Loyc.Syntax.SourcePosAndIndex"/> which are
            automatically recognized by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.LineToIndex(System.Int32)"/> which thereby 
            recovers the original index.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePosAndIndex">
            <summary>Please use the new name of this class, LineColumnFile.
            This is a <see cref="T:Loyc.Syntax.LineColumnFile"/> that also includes the original index 
            from which the Line and PosInLine were derived.</summary>
            <remarks>Returned by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.IndexToLine(System.Int32)"/>.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LineColumnFileAndIndex">
            <summary>This is a tuple of a FileName, Line, Column, and OriginalIndex.</summary>
        </member>
        <member name="T:Loyc.Syntax.LineRemapper">
            <summary>A small helper class for languages such as C# and C++ that permit 
            the locations reported by error messages to be remapped. This class stores
            and applies such commands (#line in C#/C++)</summary>
            <remarks>
            This is part of <see cref="T:Loyc.Syntax.SourceFileWithLineRemaps"/>.
            One LineRemapper should be created per real source file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.AddRemap(System.Int32,System.Int32,System.String)">
            <summary>Adds a mapping that starts on the specified real line.</summary>
            <remarks>In C++ and C#, a directive like "#line 200" affects the line 
            after the preprocessor directive. So if "#line 200" is on line 10, 
            you'd call AddRemap(11, 200) or possibly AddRemap(10, 199).</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.EndRemap(System.Int32)">
            <summary>Corresponds to <c>#line default</c> in C#.</summary>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.Remap(System.Int32@,System.String@)">
            <summary>Remaps the specified line number, if a remapping has been created that applies to it.</summary>
            <param name="line">On entry, a real line number. On exit, a remapped line number</param>
            <param name="fileName">This is changed to the user-specified file name 
            string, if and only if a file-name remapping exists and applies here.</param>
            <returns>true if a remapping exists and was applied, false if not.</returns>
        </member>
        <member name="T:Loyc.Syntax.SourceFile`1">
            <summary>A default implementation of ISourceFile based on <see cref="T:Loyc.Syntax.IndexPositionMapper"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.StreamCharSource">
            <summary>
            Exposes a stream as an ICharSource, as though it were an array of 
            characters. The stream must support seeking, and if a text decoder 
            is specified, it must meet certain constraints.
            </summary><remarks>
            This class reads small blocks of bytes from a stream, reloading 
            blocks from the stream when necessary. Data is cached with a pair 
            of character buffers, and a third buffer is used to read from the
            stream. A Stream is required rather than a TextReader because
            TextReader doesn't support seeking.
            <para/>
            This class assumes the underlying stream never changes.
            <para/>
            The stream does not (and probably cannot, if I understand the 
            System.Text.Decoder API correctly) save the decoder state at each block 
            boundary. Consequently, only encodings that meet special constraints
            will work with StreamCharSource. These include Encoding.Unicode,
            Encoding.UTF8, and Encoding.UTF32, but not Encoding.UTF7. Using 
            unsupported encodings will cause exceptions and/or or corrupted data 
            output while reading from the StreamCharSource.
            <para/>
            The decoder must meet the following constraints:
            1. Characters must be divided on a byte boundary. UTF-7 doesn't work 
               because some characters are encoded using Base64.
            2. Between characters output by the decoder, the decoder must be 
               stateless. Therefore, encodings that support compression generally 
               won't work.
            3. The decoder must produce at least one character from a group of 
               8 bytes (StreamCharSource.MaxSeqSize).
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._blkOffsets">
            <summary>A sorted list of mappings between byte positions and character 
            indexes. In each Pair(of A,B), A is the character index and B is the byte 
            index. This list is built on-demand.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._reachedEnd">
            <summary>Set true when the last block has been scanned. If true, then
            _eofIndex and _eofPosition indicate the Count and the size of the 
            stream, respectively.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofIndex">
            <summary>_eofIndex is the character index of EOF if it has been reached 
            or, if not, the index of the first unscanned character. _eofIndex 
            equals _blkOffsets[_blkOffsets.Count-1].A.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofPosition">
            <summary>_eofPosition is the byte position of EOF if it has been reached 
            or, if not, the position of the first unscanned character. _eofPosition 
            equals _blkOffsets[_blkOffsets.Count-1].B.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceRange">
            <summary>
            Holds a reference to a source file (ISourceFile&lt;char&gt;) and the
            beginning and end indices of a range in that file.
            </summary>
        </member>
        <member name="P:Loyc.Syntax.SourceRange.Source">
            <summary>Returns the source file of which this range is a part.
            If this <see cref="T:Loyc.Syntax.SourceRange"/> represents a "synthetic" syntax tree 
            (created programmatically), the source file may be an empty "dummy" 
            object such as <see cref="T:Loyc.Syntax.EmptySourceFile"/>. In this case, the 
            <see cref="P:Loyc.Syntax.SourceRange.Length"/> should be zero.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.SourceRange.Normalized">
            <summary>If the Length is negative so StartIndex > EndIndex, this returns a 
            copy of the range with StartIndex and EndIndex swapped; otherwise the same 
            range is returned.</summary>
            <exception cref="T:System.OverflowException">An integer overflow occurred.</exception>
        </member>
        <member name="M:Loyc.Syntax.SourceRange.GetRangeOfOverlap(Loyc.Syntax.SourceRange)">
            <summary>Assuming both ranges are normalized, returns the range of overlap between them.
            If the ranges are in different files or do not overlap, null is returned. If the two
            ranges share a border, this method returns a zero-Length range.</summary>
        </member>
        <member name="M:Loyc.Syntax.SourceRange.Overlaps(Loyc.Syntax.SourceRange)">
            <summary>Returns true if, assuming both ranges are normalized, the two regions 
            share at least one common character.</summary>
            <remarks>Note: this returns false if either of the ranges has a Length of zero 
            and is at the boundary of the other range.</remarks>
        </member>
        <member name="T:LeMP.IMacroContext">
            <summary>This interface provides services offered by the lexical macro processor (LeMP).</summary>
            <remarks>Macros receive this as their second argument (see <see cref="T:LeMP.LexicalMacro"/>)</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Sink">
            <summary>Returns the message sink, used for writing warnings and errors.</summary>
            <remarks>For backward compatibility, IMacroContext itself implements 
            IMessageSink also.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.ScopedProperties">
            <summary>Returns a table of "properties" (arbitrary key-value pairs)
            that exist in the current scope. This dictionary is "persistent" in the
            computer science sense; any changes to these properties affect only the
            current scope and child scopes. When the current scope ends, the set of 
            properties that existed in the parent scope are restored.</summary>
            <remarks>
            Scopes are bounded by curly brace nodes (Call nodes named "{}").
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Ancestors">
            <summary>Returns a list of ancestors of the current node being 
            processed. Normally Ancestors[0] is a #splice node that contains a list 
            of all top-level statements in the file, and Ancestors.Last() is the
            current node.</summary>
            <remarks>You would expect that Ancestors[N] would contain Ancestors[N+1]
            as part of the attributes, target or arguments, but this is not always
            true. The ancestor list contains original versions of each node; when a
            child node is changed by a macro, the parent is not updated in this 
            list, but macro processing continues for the descendants of that child,
            so the ancestor list may occasionally seem incoherent.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.PreviousSiblings">
            <summary>Returns a list of nodes that are previous siblings of the current 
            node, and have already been processed by the macro processor.</summary>
            <remarks>
            Previous nodes cannot be altered and will typically end up in the output.
            However, if the current macro was invoked because another macro called
            PreProcess or <see cref="M:LeMP.IMacroContext.PreProcessChildren"/>, the other macro will
            not necessarily include the results of the preprocess operation in its
            own output. In that case, the output will include neither PreviousSiblings 
            nor the output from the current macro.
            <para/>
            This property is the same as AncestorsAndPreviousSiblings.Last().Item1.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.AncestorsAndPreviousSiblings">
            <summary>Returns a list of pairs in which the second item is an ancestor
            of the current node (except the final item, which is the current node)
            and the first item is the previously processed siblings of that node.</summary>
            <remarks>
            For example, given code such as this:
            <code>
              using System;
              class C {
                  int x;
                  int y;
                  foo();
                  oof();
              }
            </code>
            If the macro foo() is being processed, this property will contain two
            items. The first item is
            <code>
              ( LNode.List(quote { using System; }), 
                quote {
                  class C {
                    int x;
                    int y;
                    foo();
                    oof();
                } )
            </code>
            And the second is 
            <code>
              (LNode.List(quote { int x; }, quote { int y; }), quote(foo()))
            </code>
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Parent">
            <summary>Gets the logical parent of the current node, which is 
            <c>Ancestors[Ancestors.Count - 2]</c>, or null if the current node
            is the root node.</summary>
            <remarks>Please note that the current node may not actually exist in 
            the parent node due to changes made earlier to the current node by 
            other macros (or even the same macro); the Parent property still 
            returns the old version of the parent node.</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcessChildren">
            <summary>Applies all available macros to the current node's children 
            and returns the result.</summary>
            <remarks>
            This method only processes children once. If this method is called 
            again for the same node, it returns a cached result.
            <para/>
            If the currently-running macro fails, the result may be thrown away
            and the effort of processing the children will have been wasted. If
            the macro succeeds, and its <see cref="T:LeMP.LexicalMacroAttribute"/> uses
            the default <c>MacroMode.Normal</c> processing mode, the children 
            will (normally) be processed again after the macro returns.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.RemainingNodes">
            <summary>Gets a list of the remaining nodes (arguments/statements or 
            attributes) after this point in the code stream.</summary>
            <remarks>
            The list is null when processing a target node.
            <para/>
            For example, if your macro is called "macro" and it appears in the
            following context:
            <code>{
              a();
              macro(b());
              c();
              d();
            }</code>
            Then this list will contain two items, c() and d(). Similarly, if
            the context is <c>[a, b, macro(c), d, e]</c> then the list will contain
            the items d and e.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.IsAttribute">
            <summary>Returns true if the current node is in the attribute list of 
            its immediate parent.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.IsTarget">
            <summary>Returns true if the current node is the target of its parent
            call node.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.DropRemainingNodes">
            <summary>Gets or sets a value that indicates whether to drop all 
            remaining node after the current one when the current macro returns.
            This property has no effect if the macro rejects the input by returning 
            null.</summary>
            <remarks>See remarks at <see cref="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Syntax.LNodeList,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Runs the macro processor on the specified node(s).</summary>
            <param name="input">The node or node list to process.</param>
            <param name="asRoot">If false, the nodes are treated as children of the 
              current node (using the current list of ancestors as a basis); if true,
              the list of parent nodes is cleared.</param>
            <param name="resetOpenNamespaces">If false, the set of open namespaces
              stays the same; if true it is cleared to the set of pre-opened 
              namespaces (<see cref="!:MacroProcessor.PreOpenedNamespaces"/>) and
              macros defined with <see cref="M:LeMP.IMacroContext.RegisterMacro(LeMP.MacroInfo)"/> are forgotten.</param>
            <param name="resetProperties">If true, <see cref="P:LeMP.IMacroContext.ScopedProperties"/>
              is reset to contain only predefined properties.</param>
            <param name="areAttributes">This parameter controls the value of 
              <see cref="P:LeMP.IMacroContext.IsAttribute"/> while the items in the list are processed.</param>
            <remarks>The node(s)</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Syntax.LNode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:LeMP.IMacroContext.PreProcess(Loyc.Syntax.LNodeList,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:LeMP.IMacroContext.AllKnownMacros">
            <summary>Gets information about all macros registered with the macro 
            processor, including macros whose namespace has not been opened with
            <c>#importMacros</c>.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.NextTempCounter">
            <summary>Gets the next number to use as a suffix for temporary variables (without incrementing it).</summary>
        </member>
        <member name="M:LeMP.IMacroContext.IncrementTempCounter">
            <summary>Gets the next number to use as a suffix for temporary variables, then increments it.</summary>
        </member>
        <member name="M:LeMP.IMacroContext.RegisterMacro(LeMP.MacroInfo)">
            <summary>Registers a new macro in the current scope.</summary>
            <param name="macroInfo">Information about the macro</param>
            <remarks>
            The macro will be forgotten at the end of the current scope (regardless 
            of which namespace it is assigned to).
            <para/>
            Macros defined in child scopes do not shadow macros in outer scopes; 
            if there are macros with the same name in the outer scopes, conflicts are 
            handled in the same way as with groups of macros that are imported in the 
            same scope. For example, <c>Mode = <see cref="F:LeMP.MacroMode.PriorityOverride"/></c>
            can be used to make macros that override normal-priority macros.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.OpenMacroNamespaces">
            <summary>Gets the list of namespaces that are being searched for macros in 
            the current scope. LeMP allows you to modify this collection.</summary>
            <remarks>The naming scheme of namespaces is not standardized in cases where
            the namespace name is not a "normal" identifier. It is recommended that 
            macros be placed in namespaces whose names are valid identifiers in most 
            languages (C++, C#, Java, Python, etc.). It's okay to put macros in nested
            namespaces; the Symbol.Name will have a format like "Namespace1.Namespace2".
            </remarks>
        </member>
        <member name="T:LeMP.MacroContext">
            <summary>Standard extension methods for <see cref="T:LeMP.IMacroContext"/>.</summary>
        </member>
        <member name="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)">
            <summary>Splits the current node into a pair of "argument" and "body" 
            lists, potentially treating ctx.RemainingNodes as the "body" list.</summary>
            <param name="ctx">Context of the current macro.</param>
            <param name="orRemainingNodes">Whether to use ctx.RemainingNodes as
            the second list if there is no {braces node} at the end of 
            ctx.CurrentNode().Args.</param>
            <returns>A pair where the first item is "arguments" and the second is 
            the "body". If no body was detected then the second list is empty and
            the first list is simply ctx.CurrentNode().Args.</returns>
            <remarks>
            EC# supports a syntax specially designed for macro calls: 
            <code>macroName(args) { stmts; }</code>
            This is stored as a call node with a body, in braces, as its final parameter,
            i.e. it is equivalent to
            <code>macroName(args, { stmts; });</code>
            A similar, but more general feature called "superexpressions" exists in LES.
            <para/>
            Some macros would additionally like to apply themselves to all remaining
            nodes in the current list of statements or expressions, i.e.
            <code>macroName(args); stmts;</code>
            LeMP supports this through the <see cref="P:LeMP.IMacroContext.DropRemainingNodes"/>
            and <see cref="P:LeMP.IMacroContext.RemainingNodes"/> APIs. If your macro wants
            to apply itself to all remaining statements or expressions in the 
            current sequence of nodes, it can set the DropRemainingNodes property 
            to true and then simply incorporate RemainingNodes into its own output
            (if you need to return multiple statements from your macro, use 
            <c>list.AsLNode(CodeSymbols.Splice)</c> to convert a VList{LNode} to an 
            LNode.)
            <para/>
            This extension method helps you by detecting whether the current node
            has a body in braces or not. If the braces are present, the returned
            pair consists of the args shortened by one (i.e.
            <c>ctx.CurrentNode().Args.WithoutLast(1)</c>) and the Args of the "{}"
            braces node. Otherwise, <c>ctx.CurrentNode().Args</c> is the first item
            in the pair.
            <para/>
            In the latter case, if <c>orRemainingNodes</c> then this method sets
            <c>ctx.DropRemainingNodes</c> to true and uses <c>ctx.RemainingNodes</c>
            as the second list. Otherwise the second list is left blank.
            </remarks>
        </member>
        <member name="M:LeMP.MacroContext.GetOptions(Loyc.Syntax.LNodeList)">
            <summary>Transforms an option list in the format <c>option1(v1), option2(v2)</c> 
            or <c>option1: v1, option2: v2</c> into a sequence of (key, value) pairs.
            If the format of a given node is invalid, this function yields <c>(node, null)</c>.</summary>
            <remarks>
            <c>option1: v1, option2: v2</c> is parsed into <c>@`'::=`(option1, v1), 
            @`'::=`(option2, v2)</c> in EC# or <c>@`':`(option1, v1), @`':`(option2, v2)</c> in LES.
            </remarks>
        </member>
        <member name="T:LeMP.LexicalMacro">
            <summary>Method signature of an LeMP macro.</summary>
            <param name="node">The node that caused the macro to be invoked (includes 
            the name of the macro itself, and any attributes applied to the macro)</param>
            <param name="context">This is a dual-purpose object. Firstly, this object
            implements <see cref="T:Loyc.IMessageSink"/>. if the input does not have a valid 
            form, the macro rejects it by returning null. Before returning null, the 
            macro should explain the reason for the rejection (including a pattern that 
            the macro accepts) by writinga message to this object. Secondly, this 
            object contains additional information including the ancestors of the 
            current node and a list of "scoped properties" (see <see cref="T:LeMP.IMacroContext"/>.)
            </param>
            <returns>A node to replace the original <c>node</c>, or null if this 
            macro rejects the input node. Returning null can allow a different macro 
            to accept the node instead.</returns>
            <remarks>
            When the macro processor scans an assembly looking for macros, it requires
            <see cref="T:LeMP.ContainsMacrosAttribute"/> on the containing class, and 
            <see cref="T:LeMP.LexicalMacroAttribute"/> on each macro in the class. The macros 
            must be public static methods.
            <para/>
            If there are multiple macros in scope with the same name, they 
            are <i>all</i> called. Macro expansion succeeds if exactly one macro accepts 
            the input. If no macros accept the input, the error message given by each
            macro is printed; if multiple macros accept the input, an ambiguity error
            is printed (which is downgraded to a warning if their outputs are the same).
            </remarks>
        </member>
        <member name="T:LeMP.ContainsMacrosAttribute">
            <summary>Marks a class to be searched for macros.</summary>
            <remarks>The method signature of a macro must be <see cref="T:LeMP.LexicalMacro"/> and
            it must be marked with <see cref="T:LeMP.LexicalMacroAttribute"/>.</remarks>
        </member>
        <member name="T:LeMP.LexicalMacroAttribute">
            <summary>Marks a method as a LeMP lexical macro.</summary>
            <remarks>
            To be recognized as a macro, the method must be public and static and its 
            signature must be <see cref="T:LeMP.LexicalMacro"/>. A class will not be automatically
            searched for macros unless the class is marked with <see cref="T:LeMP.ContainsMacrosAttribute"/>.</remarks>
        </member>
        <member name="M:LeMP.LexicalMacroAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>LexicalMacroAttribute constuctor.</summary>
            <param name="syntax">A string that shows the expected syntax used to call the node.</param>
            <param name="description"></param>
            <param name="names"></param>
        </member>
        <member name="T:LeMP.MacroMode">
            <summary>Flags that affect the way that <see cref="!:LeMP.MacroProcessor"/>
            uses a LexicalMacro.</summary>
        </member>
        <member name="F:LeMP.MacroMode.Normal">
            <summary>The macro's result is reprocessed directly (this is the default behavior).</summary>
        </member>
        <member name="F:LeMP.MacroMode.NoReprocessing">
            <summary>The macro's result (including children) is not processed further. 
            This flag only takes effect when the macro accepts the input by returning a non-null result.</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenAfter">
            <summary>The macro's result is not reprocessed, but the result's children are processed. 
            This flag only takes effect when the macro accepts the input by returning a non-null result.</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenBefore">
            <summary>The result is pre-processed before calling the macro, and not processed afterward
            (if the macro accepts the input by returning a non-null result).</summary>
        </member>
        <member name="F:LeMP.MacroMode.Passive">
            <summary>It is normal for this macro not to change the code, so a warning should not be printed when the macro "rejects" the input by returning null.</summary>
        </member>
        <member name="F:LeMP.MacroMode.AllowDuplicates">
            <summary>If this macro is ambiguous with one or more macro of the same priority, this flag blocks the ambiguity error message if all the macros produce equivalent results.</summary>
        </member>
        <member name="F:LeMP.MacroMode.DropRemainingListItems">
            <summary>If this macro succeeds, all nodes after this one in the current attribute or statement/argument list are dropped.</summary>
            <remarks>This option may be used by macros that splice together the list of <see cref="P:LeMP.IMacroContext.RemainingNodes"/> into their own result.
            It is more common, however, to set the <see cref="P:LeMP.IMacroContext.DropRemainingNodes"/> property inside the macro.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.MatchIdentifier">
            <summary>If this flag is present, the macro can match a plain identifier. By default, only calls can be treated as macros.</summary>
            <remarks>This flag does <i>not</i> prevent the macro from matching calls.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.MatchIdentifierOnly">
            <summary>If this flag is present, the macro can match a plain identifier but cannot match calls.</summary>
        </member>
        <member name="F:LeMP.MacroMode.MatchEveryLiteral">
            <summary>The macro will be called whenever any kind of literal is encountered
            (if its namespace is imported).</summary>
            <remarks>When a literal is encountered, it is processed as though the Passive 
            flag were present on all macros that use this flag, because no macro should alter 
            all literals.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.MatchEveryCall">
            <summary>The macro will be called for every call node
            (if its namespace is imported).</summary>
            <remarks>When a macro with this flag is called, it is processed as though the 
            Passive flag were present.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.MatchEveryIdentifier">
            <summary>The macro will be called for every identifier node 
            (if its namespace is imported).</summary>
            <remarks>When a macro with this flag is called, it is processed as though the 
            Passive flag were present.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.UseLogicalNameInErrorMessages">
            <summary>Tells LeMP not to mention the physical method that implements the macro.
            This improves error message clarity for user-defined macros, all of which share 
            a single implementing method.</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityFallbackMin">
            <summary>Lowest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityFallback">
            <summary>Low priority. If this macro is ambiguous with another macro that doesn't have this flag nor FallbackMin, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityInternalFallback">
            <summary>Used to order behavior of standard macros.</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityNormal">
            <summary>Normal priority (this is the default and does not need to be specified.)</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityInternalOverride">
            <summary>Used to order behavior of standard macros.</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityOverride">
            <summary>High priority. If this macro is ambiguous with another macro that doesn't have this flag nor OverrideAll, this macro takes precedence (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityOverrideMax">
            <summary>Highest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by this macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityMask">
            <summary>For internal use to isolate the priority of a macro.</summary>
        </member>
        <member name="T:LeMP.MacroInfo">
            <summary>Data returned from <see cref="P:LeMP.IMacroContext.AllKnownMacros"/></summary>
        </member>
        <member name="M:LeMP.MacroInfo.GetMacros(System.Type,Loyc.IMessageSink,Loyc.Symbol,System.Object)">
            <summary>Uses reflection to find a list of macros within the specified 
            type by searching for (static) methods that
            (1) are marked with <see cref="T:LeMP.LexicalMacroAttribute"/> and
            (2) take no parameters and return a list (IEnumerable) of 
                <see cref="T:LeMP.MacroInfo"/>. Such methods are called to get macros.
            </summary>
            <param name="type">The type to search for macros.</param>
            <param name="namespace">Optionally overrides the namespace associated 
            with macros marked with <see cref="T:LeMP.LexicalMacroAttribute"/>. Does not
            affect macros returned in a list of <see cref="T:LeMP.MacroInfo"/>.</param>
            <param name="errorSink">An object in which to send error messages
            (<see cref="F:Loyc.Severity.Warning"/> is used because unavailability of a macro
            should not appear as an error when compiling something with LeMP.)</param>
            <param name="instance">An optional object of the same type as <c>type</c>, 
            which will be used to bind instance methods. If this is null, only static
            methods are discovered.</param>
            <returns></returns>
        </member>
    </members>
</doc>
